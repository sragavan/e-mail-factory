/*
 * Generated by gdbus-codegen 2.30.0. DO NOT EDIT.
 *
 * The license of this code is the same as for the source it was derived from.
 */

#ifdef HAVE_CONFIG_H
#  include "config.h"
#endif

#include "e-gdbus-emailfolder.h"

#ifdef G_OS_UNIX
#  include <gio/gunixfdlist.h>
#endif

typedef struct
{
  GDBusArgInfo parent_struct;
  gboolean use_gvariant;
} _ExtendedGDBusArgInfo;

typedef struct
{
  GDBusMethodInfo parent_struct;
  const gchar *signal_name;
  gboolean pass_fdlist;
} _ExtendedGDBusMethodInfo;

typedef struct
{
  GDBusSignalInfo parent_struct;
  const gchar *signal_name;
} _ExtendedGDBusSignalInfo;

typedef struct
{
  GDBusPropertyInfo parent_struct;
  const gchar *hyphen_name;
  gboolean use_gvariant;
} _ExtendedGDBusPropertyInfo;

typedef struct
{
  GDBusInterfaceInfo parent_struct;
  const gchar *hyphen_name;
} _ExtendedGDBusInterfaceInfo;

typedef struct
{
  const _ExtendedGDBusPropertyInfo *info;
  guint prop_id;
  GValue orig_value; /* the value before the change */
} ChangedProperty;

static void
_changed_property_free (ChangedProperty *data)
{
  g_value_unset (&data->orig_value);
  g_free (data);
}

static gboolean
_g_strv_equal0 (gchar **a, gchar **b)
{
  gboolean ret = FALSE;
  guint n;
  if (a == NULL && b == NULL)
    {
      ret = TRUE;
      goto out;
    }
  if (a == NULL || b == NULL)
    goto out;
  if (g_strv_length (a) != g_strv_length (b))
    goto out;
  for (n = 0; a[n] != NULL; n++)
    if (g_strcmp0 (a[n], b[n]) != 0)
      goto out;
  ret = TRUE;
out:
  return ret;
}

static gboolean
_g_variant_equal0 (GVariant *a, GVariant *b)
{
  gboolean ret = FALSE;
  if (a == NULL && b == NULL)
    {
      ret = TRUE;
      goto out;
    }
  if (a == NULL || b == NULL)
    goto out;
  ret = g_variant_equal (a, b);
out:
  return ret;
}

G_GNUC_UNUSED static gboolean
_g_value_equal (const GValue *a, const GValue *b)
{
  gboolean ret = FALSE;
  g_assert (G_VALUE_TYPE (a) == G_VALUE_TYPE (b));
  switch (G_VALUE_TYPE (a))
    {
      case G_TYPE_BOOLEAN:
        ret = (g_value_get_boolean (a) == g_value_get_boolean (b));
        break;
      case G_TYPE_UCHAR:
        ret = (g_value_get_uchar (a) == g_value_get_uchar (b));
        break;
      case G_TYPE_INT:
        ret = (g_value_get_int (a) == g_value_get_int (b));
        break;
      case G_TYPE_UINT:
        ret = (g_value_get_uint (a) == g_value_get_uint (b));
        break;
      case G_TYPE_INT64:
        ret = (g_value_get_int64 (a) == g_value_get_int64 (b));
        break;
      case G_TYPE_UINT64:
        ret = (g_value_get_uint64 (a) == g_value_get_uint64 (b));
        break;
      case G_TYPE_DOUBLE:
        ret = (g_value_get_double (a) == g_value_get_double (b));
        break;
      case G_TYPE_STRING:
        ret = (g_strcmp0 (g_value_get_string (a), g_value_get_string (b)) == 0);
        break;
      case G_TYPE_VARIANT:
        ret = _g_variant_equal0 (g_value_get_variant (a), g_value_get_variant (b));
        break;
      default:
        if (G_VALUE_TYPE (a) == G_TYPE_STRV)
          ret = _g_strv_equal0 (g_value_get_boxed (a), g_value_get_boxed (b));
        else
          g_critical ("_g_value_equal() does not handle type %s", g_type_name (G_VALUE_TYPE (a)));
        break;
    }
  return ret;
}

/* ------------------------------------------------------------------------
 * Code for interface org.gnome.evolution.dataserver.mail.Folder
 * ------------------------------------------------------------------------
 */

/**
 * SECTION:EGdbusFolder
 * @title: EGdbusFolder
 * @short_description: Generated C code for the org.gnome.evolution.dataserver.mail.Folder D-Bus interface
 *
 * This section contains code for working with the <link linkend="gdbus-interface-org-gnome-evolution-dataserver-mail-Folder.top_of_page">org.gnome.evolution.dataserver.mail.Folder</link> D-Bus interface in C.
 */

/* ---- Introspection data for org.gnome.evolution.dataserver.mail.Folder ---- */

static const _ExtendedGDBusArgInfo _egdbus_folder_method_info_refresh_info_IN_ARG_ops =
{
  {
    -1,
    "ops",
    "o",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _egdbus_folder_method_info_refresh_info_IN_ARG_pointers[] =
{
  &_egdbus_folder_method_info_refresh_info_IN_ARG_ops,
  NULL
};

static const _ExtendedGDBusArgInfo _egdbus_folder_method_info_refresh_info_OUT_ARG_success =
{
  {
    -1,
    "success",
    "b",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _egdbus_folder_method_info_refresh_info_OUT_ARG_pointers[] =
{
  &_egdbus_folder_method_info_refresh_info_OUT_ARG_success,
  NULL
};

static const _ExtendedGDBusMethodInfo _egdbus_folder_method_info_refresh_info =
{
  {
    -1,
    "refreshInfo",
    (GDBusArgInfo **) &_egdbus_folder_method_info_refresh_info_IN_ARG_pointers,
    (GDBusArgInfo **) &_egdbus_folder_method_info_refresh_info_OUT_ARG_pointers,
    NULL
  },
  "handle-refresh-info",
  FALSE
};

static const _ExtendedGDBusArgInfo _egdbus_folder_method_info_sync_IN_ARG_expunge =
{
  {
    -1,
    "expunge",
    "b",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _egdbus_folder_method_info_sync_IN_ARG_ops =
{
  {
    -1,
    "ops",
    "o",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _egdbus_folder_method_info_sync_IN_ARG_pointers[] =
{
  &_egdbus_folder_method_info_sync_IN_ARG_expunge,
  &_egdbus_folder_method_info_sync_IN_ARG_ops,
  NULL
};

static const _ExtendedGDBusArgInfo _egdbus_folder_method_info_sync_OUT_ARG_success =
{
  {
    -1,
    "success",
    "b",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _egdbus_folder_method_info_sync_OUT_ARG_pointers[] =
{
  &_egdbus_folder_method_info_sync_OUT_ARG_success,
  NULL
};

static const _ExtendedGDBusMethodInfo _egdbus_folder_method_info_sync =
{
  {
    -1,
    "sync",
    (GDBusArgInfo **) &_egdbus_folder_method_info_sync_IN_ARG_pointers,
    (GDBusArgInfo **) &_egdbus_folder_method_info_sync_OUT_ARG_pointers,
    NULL
  },
  "handle-sync",
  FALSE
};

static const _ExtendedGDBusArgInfo _egdbus_folder_method_info_sync_message_IN_ARG_uid =
{
  {
    -1,
    "uid",
    "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _egdbus_folder_method_info_sync_message_IN_ARG_ops =
{
  {
    -1,
    "ops",
    "o",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _egdbus_folder_method_info_sync_message_IN_ARG_pointers[] =
{
  &_egdbus_folder_method_info_sync_message_IN_ARG_uid,
  &_egdbus_folder_method_info_sync_message_IN_ARG_ops,
  NULL
};

static const _ExtendedGDBusArgInfo _egdbus_folder_method_info_sync_message_OUT_ARG_success =
{
  {
    -1,
    "success",
    "b",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _egdbus_folder_method_info_sync_message_OUT_ARG_pointers[] =
{
  &_egdbus_folder_method_info_sync_message_OUT_ARG_success,
  NULL
};

static const _ExtendedGDBusMethodInfo _egdbus_folder_method_info_sync_message =
{
  {
    -1,
    "syncMessage",
    (GDBusArgInfo **) &_egdbus_folder_method_info_sync_message_IN_ARG_pointers,
    (GDBusArgInfo **) &_egdbus_folder_method_info_sync_message_OUT_ARG_pointers,
    NULL
  },
  "handle-sync-message",
  FALSE
};

static const _ExtendedGDBusArgInfo _egdbus_folder_method_info_expunge_IN_ARG_ops =
{
  {
    -1,
    "ops",
    "o",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _egdbus_folder_method_info_expunge_IN_ARG_pointers[] =
{
  &_egdbus_folder_method_info_expunge_IN_ARG_ops,
  NULL
};

static const _ExtendedGDBusArgInfo _egdbus_folder_method_info_expunge_OUT_ARG_success =
{
  {
    -1,
    "success",
    "b",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _egdbus_folder_method_info_expunge_OUT_ARG_pointers[] =
{
  &_egdbus_folder_method_info_expunge_OUT_ARG_success,
  NULL
};

static const _ExtendedGDBusMethodInfo _egdbus_folder_method_info_expunge =
{
  {
    -1,
    "expunge",
    (GDBusArgInfo **) &_egdbus_folder_method_info_expunge_IN_ARG_pointers,
    (GDBusArgInfo **) &_egdbus_folder_method_info_expunge_OUT_ARG_pointers,
    NULL
  },
  "handle-expunge",
  FALSE
};

static const _ExtendedGDBusArgInfo _egdbus_folder_method_info_get_display_name_OUT_ARG_name =
{
  {
    -1,
    "name",
    "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _egdbus_folder_method_info_get_display_name_OUT_ARG_pointers[] =
{
  &_egdbus_folder_method_info_get_display_name_OUT_ARG_name,
  NULL
};

static const _ExtendedGDBusMethodInfo _egdbus_folder_method_info_get_display_name =
{
  {
    -1,
    "getDisplayName",
    NULL,
    (GDBusArgInfo **) &_egdbus_folder_method_info_get_display_name_OUT_ARG_pointers,
    NULL
  },
  "handle-get-display-name",
  FALSE
};

static const _ExtendedGDBusArgInfo _egdbus_folder_method_info_set_display_name_IN_ARG_name =
{
  {
    -1,
    "name",
    "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _egdbus_folder_method_info_set_display_name_IN_ARG_pointers[] =
{
  &_egdbus_folder_method_info_set_display_name_IN_ARG_name,
  NULL
};

static const _ExtendedGDBusMethodInfo _egdbus_folder_method_info_set_display_name =
{
  {
    -1,
    "setDisplayName",
    (GDBusArgInfo **) &_egdbus_folder_method_info_set_display_name_IN_ARG_pointers,
    NULL,
    NULL
  },
  "handle-set-display-name",
  FALSE
};

static const _ExtendedGDBusArgInfo _egdbus_folder_method_info_get_full_name_OUT_ARG_name =
{
  {
    -1,
    "name",
    "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _egdbus_folder_method_info_get_full_name_OUT_ARG_pointers[] =
{
  &_egdbus_folder_method_info_get_full_name_OUT_ARG_name,
  NULL
};

static const _ExtendedGDBusMethodInfo _egdbus_folder_method_info_get_full_name =
{
  {
    -1,
    "getFullName",
    NULL,
    (GDBusArgInfo **) &_egdbus_folder_method_info_get_full_name_OUT_ARG_pointers,
    NULL
  },
  "handle-get-full-name",
  FALSE
};

static const _ExtendedGDBusArgInfo _egdbus_folder_method_info_set_full_name_IN_ARG_name =
{
  {
    -1,
    "name",
    "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _egdbus_folder_method_info_set_full_name_IN_ARG_pointers[] =
{
  &_egdbus_folder_method_info_set_full_name_IN_ARG_name,
  NULL
};

static const _ExtendedGDBusMethodInfo _egdbus_folder_method_info_set_full_name =
{
  {
    -1,
    "setFullName",
    (GDBusArgInfo **) &_egdbus_folder_method_info_set_full_name_IN_ARG_pointers,
    NULL,
    NULL
  },
  "handle-set-full-name",
  FALSE
};

static const _ExtendedGDBusArgInfo _egdbus_folder_method_info_get_description_OUT_ARG_desc =
{
  {
    -1,
    "desc",
    "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _egdbus_folder_method_info_get_description_OUT_ARG_pointers[] =
{
  &_egdbus_folder_method_info_get_description_OUT_ARG_desc,
  NULL
};

static const _ExtendedGDBusMethodInfo _egdbus_folder_method_info_get_description =
{
  {
    -1,
    "getDescription",
    NULL,
    (GDBusArgInfo **) &_egdbus_folder_method_info_get_description_OUT_ARG_pointers,
    NULL
  },
  "handle-get-description",
  FALSE
};

static const _ExtendedGDBusArgInfo _egdbus_folder_method_info_set_description_IN_ARG_desc =
{
  {
    -1,
    "desc",
    "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _egdbus_folder_method_info_set_description_IN_ARG_pointers[] =
{
  &_egdbus_folder_method_info_set_description_IN_ARG_desc,
  NULL
};

static const _ExtendedGDBusMethodInfo _egdbus_folder_method_info_set_description =
{
  {
    -1,
    "setDescription",
    (GDBusArgInfo **) &_egdbus_folder_method_info_set_description_IN_ARG_pointers,
    NULL,
    NULL
  },
  "handle-set-description",
  FALSE
};

static const _ExtendedGDBusArgInfo _egdbus_folder_method_info_get_permanent_flags_OUT_ARG_flags =
{
  {
    -1,
    "flags",
    "u",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _egdbus_folder_method_info_get_permanent_flags_OUT_ARG_pointers[] =
{
  &_egdbus_folder_method_info_get_permanent_flags_OUT_ARG_flags,
  NULL
};

static const _ExtendedGDBusMethodInfo _egdbus_folder_method_info_get_permanent_flags =
{
  {
    -1,
    "getPermanentFlags",
    NULL,
    (GDBusArgInfo **) &_egdbus_folder_method_info_get_permanent_flags_OUT_ARG_pointers,
    NULL
  },
  "handle-get-permanent-flags",
  FALSE
};

static const _ExtendedGDBusArgInfo _egdbus_folder_method_info_has_summary_capability_OUT_ARG_summary =
{
  {
    -1,
    "summary",
    "b",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _egdbus_folder_method_info_has_summary_capability_OUT_ARG_pointers[] =
{
  &_egdbus_folder_method_info_has_summary_capability_OUT_ARG_summary,
  NULL
};

static const _ExtendedGDBusMethodInfo _egdbus_folder_method_info_has_summary_capability =
{
  {
    -1,
    "hasSummaryCapability",
    NULL,
    (GDBusArgInfo **) &_egdbus_folder_method_info_has_summary_capability_OUT_ARG_pointers,
    NULL
  },
  "handle-has-summary-capability",
  FALSE
};

static const _ExtendedGDBusArgInfo _egdbus_folder_method_info_has_search_capability_OUT_ARG_search =
{
  {
    -1,
    "search",
    "b",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _egdbus_folder_method_info_has_search_capability_OUT_ARG_pointers[] =
{
  &_egdbus_folder_method_info_has_search_capability_OUT_ARG_search,
  NULL
};

static const _ExtendedGDBusMethodInfo _egdbus_folder_method_info_has_search_capability =
{
  {
    -1,
    "hasSearchCapability",
    NULL,
    (GDBusArgInfo **) &_egdbus_folder_method_info_has_search_capability_OUT_ARG_pointers,
    NULL
  },
  "handle-has-search-capability",
  FALSE
};

static const _ExtendedGDBusArgInfo _egdbus_folder_method_info_total_message_count_OUT_ARG_count =
{
  {
    -1,
    "count",
    "i",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _egdbus_folder_method_info_total_message_count_OUT_ARG_pointers[] =
{
  &_egdbus_folder_method_info_total_message_count_OUT_ARG_count,
  NULL
};

static const _ExtendedGDBusMethodInfo _egdbus_folder_method_info_total_message_count =
{
  {
    -1,
    "totalMessageCount",
    NULL,
    (GDBusArgInfo **) &_egdbus_folder_method_info_total_message_count_OUT_ARG_pointers,
    NULL
  },
  "handle-total-message-count",
  FALSE
};

static const _ExtendedGDBusArgInfo _egdbus_folder_method_info_unread_message_count_OUT_ARG_count =
{
  {
    -1,
    "count",
    "i",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _egdbus_folder_method_info_unread_message_count_OUT_ARG_pointers[] =
{
  &_egdbus_folder_method_info_unread_message_count_OUT_ARG_count,
  NULL
};

static const _ExtendedGDBusMethodInfo _egdbus_folder_method_info_unread_message_count =
{
  {
    -1,
    "unreadMessageCount",
    NULL,
    (GDBusArgInfo **) &_egdbus_folder_method_info_unread_message_count_OUT_ARG_pointers,
    NULL
  },
  "handle-unread-message-count",
  FALSE
};

static const _ExtendedGDBusArgInfo _egdbus_folder_method_info_deleted_message_count_OUT_ARG_count =
{
  {
    -1,
    "count",
    "i",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _egdbus_folder_method_info_deleted_message_count_OUT_ARG_pointers[] =
{
  &_egdbus_folder_method_info_deleted_message_count_OUT_ARG_count,
  NULL
};

static const _ExtendedGDBusMethodInfo _egdbus_folder_method_info_deleted_message_count =
{
  {
    -1,
    "deletedMessageCount",
    NULL,
    (GDBusArgInfo **) &_egdbus_folder_method_info_deleted_message_count_OUT_ARG_pointers,
    NULL
  },
  "handle-deleted-message-count",
  FALSE
};

static const _ExtendedGDBusArgInfo _egdbus_folder_method_info_get_message_flags_IN_ARG_uid =
{
  {
    -1,
    "uid",
    "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _egdbus_folder_method_info_get_message_flags_IN_ARG_pointers[] =
{
  &_egdbus_folder_method_info_get_message_flags_IN_ARG_uid,
  NULL
};

static const _ExtendedGDBusArgInfo _egdbus_folder_method_info_get_message_flags_OUT_ARG_flags =
{
  {
    -1,
    "flags",
    "u",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _egdbus_folder_method_info_get_message_flags_OUT_ARG_pointers[] =
{
  &_egdbus_folder_method_info_get_message_flags_OUT_ARG_flags,
  NULL
};

static const _ExtendedGDBusMethodInfo _egdbus_folder_method_info_get_message_flags =
{
  {
    -1,
    "getMessageFlags",
    (GDBusArgInfo **) &_egdbus_folder_method_info_get_message_flags_IN_ARG_pointers,
    (GDBusArgInfo **) &_egdbus_folder_method_info_get_message_flags_OUT_ARG_pointers,
    NULL
  },
  "handle-get-message-flags",
  FALSE
};

static const _ExtendedGDBusArgInfo _egdbus_folder_method_info_set_message_flags_IN_ARG_uid =
{
  {
    -1,
    "uid",
    "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _egdbus_folder_method_info_set_message_flags_IN_ARG_flags =
{
  {
    -1,
    "flags",
    "u",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _egdbus_folder_method_info_set_message_flags_IN_ARG_set =
{
  {
    -1,
    "set",
    "u",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _egdbus_folder_method_info_set_message_flags_IN_ARG_pointers[] =
{
  &_egdbus_folder_method_info_set_message_flags_IN_ARG_uid,
  &_egdbus_folder_method_info_set_message_flags_IN_ARG_flags,
  &_egdbus_folder_method_info_set_message_flags_IN_ARG_set,
  NULL
};

static const _ExtendedGDBusArgInfo _egdbus_folder_method_info_set_message_flags_OUT_ARG_success =
{
  {
    -1,
    "success",
    "b",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _egdbus_folder_method_info_set_message_flags_OUT_ARG_pointers[] =
{
  &_egdbus_folder_method_info_set_message_flags_OUT_ARG_success,
  NULL
};

static const _ExtendedGDBusMethodInfo _egdbus_folder_method_info_set_message_flags =
{
  {
    -1,
    "setMessageFlags",
    (GDBusArgInfo **) &_egdbus_folder_method_info_set_message_flags_IN_ARG_pointers,
    (GDBusArgInfo **) &_egdbus_folder_method_info_set_message_flags_OUT_ARG_pointers,
    NULL
  },
  "handle-set-message-flags",
  FALSE
};

static const _ExtendedGDBusArgInfo _egdbus_folder_method_info_get_message_user_flag_IN_ARG_uid =
{
  {
    -1,
    "uid",
    "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _egdbus_folder_method_info_get_message_user_flag_IN_ARG_flagname =
{
  {
    -1,
    "flagname",
    "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _egdbus_folder_method_info_get_message_user_flag_IN_ARG_pointers[] =
{
  &_egdbus_folder_method_info_get_message_user_flag_IN_ARG_uid,
  &_egdbus_folder_method_info_get_message_user_flag_IN_ARG_flagname,
  NULL
};

static const _ExtendedGDBusArgInfo _egdbus_folder_method_info_get_message_user_flag_OUT_ARG_flag =
{
  {
    -1,
    "flag",
    "b",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _egdbus_folder_method_info_get_message_user_flag_OUT_ARG_pointers[] =
{
  &_egdbus_folder_method_info_get_message_user_flag_OUT_ARG_flag,
  NULL
};

static const _ExtendedGDBusMethodInfo _egdbus_folder_method_info_get_message_user_flag =
{
  {
    -1,
    "getMessageUserFlag",
    (GDBusArgInfo **) &_egdbus_folder_method_info_get_message_user_flag_IN_ARG_pointers,
    (GDBusArgInfo **) &_egdbus_folder_method_info_get_message_user_flag_OUT_ARG_pointers,
    NULL
  },
  "handle-get-message-user-flag",
  FALSE
};

static const _ExtendedGDBusArgInfo _egdbus_folder_method_info_set_message_user_flag_IN_ARG_uid =
{
  {
    -1,
    "uid",
    "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _egdbus_folder_method_info_set_message_user_flag_IN_ARG_flagname =
{
  {
    -1,
    "flagname",
    "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _egdbus_folder_method_info_set_message_user_flag_IN_ARG_set =
{
  {
    -1,
    "set",
    "u",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _egdbus_folder_method_info_set_message_user_flag_IN_ARG_pointers[] =
{
  &_egdbus_folder_method_info_set_message_user_flag_IN_ARG_uid,
  &_egdbus_folder_method_info_set_message_user_flag_IN_ARG_flagname,
  &_egdbus_folder_method_info_set_message_user_flag_IN_ARG_set,
  NULL
};

static const _ExtendedGDBusMethodInfo _egdbus_folder_method_info_set_message_user_flag =
{
  {
    -1,
    "setMessageUserFlag",
    (GDBusArgInfo **) &_egdbus_folder_method_info_set_message_user_flag_IN_ARG_pointers,
    NULL,
    NULL
  },
  "handle-set-message-user-flag",
  FALSE
};

static const _ExtendedGDBusArgInfo _egdbus_folder_method_info_get_message_user_tag_IN_ARG_uid =
{
  {
    -1,
    "uid",
    "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _egdbus_folder_method_info_get_message_user_tag_IN_ARG_param =
{
  {
    -1,
    "param",
    "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _egdbus_folder_method_info_get_message_user_tag_IN_ARG_pointers[] =
{
  &_egdbus_folder_method_info_get_message_user_tag_IN_ARG_uid,
  &_egdbus_folder_method_info_get_message_user_tag_IN_ARG_param,
  NULL
};

static const _ExtendedGDBusArgInfo _egdbus_folder_method_info_get_message_user_tag_OUT_ARG_value =
{
  {
    -1,
    "value",
    "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _egdbus_folder_method_info_get_message_user_tag_OUT_ARG_pointers[] =
{
  &_egdbus_folder_method_info_get_message_user_tag_OUT_ARG_value,
  NULL
};

static const _ExtendedGDBusMethodInfo _egdbus_folder_method_info_get_message_user_tag =
{
  {
    -1,
    "getMessageUserTag",
    (GDBusArgInfo **) &_egdbus_folder_method_info_get_message_user_tag_IN_ARG_pointers,
    (GDBusArgInfo **) &_egdbus_folder_method_info_get_message_user_tag_OUT_ARG_pointers,
    NULL
  },
  "handle-get-message-user-tag",
  FALSE
};

static const _ExtendedGDBusArgInfo _egdbus_folder_method_info_set_message_user_tag_IN_ARG_uid =
{
  {
    -1,
    "uid",
    "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _egdbus_folder_method_info_set_message_user_tag_IN_ARG_param =
{
  {
    -1,
    "param",
    "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _egdbus_folder_method_info_set_message_user_tag_IN_ARG_value =
{
  {
    -1,
    "value",
    "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _egdbus_folder_method_info_set_message_user_tag_IN_ARG_pointers[] =
{
  &_egdbus_folder_method_info_set_message_user_tag_IN_ARG_uid,
  &_egdbus_folder_method_info_set_message_user_tag_IN_ARG_param,
  &_egdbus_folder_method_info_set_message_user_tag_IN_ARG_value,
  NULL
};

static const _ExtendedGDBusMethodInfo _egdbus_folder_method_info_set_message_user_tag =
{
  {
    -1,
    "setMessageUserTag",
    (GDBusArgInfo **) &_egdbus_folder_method_info_set_message_user_tag_IN_ARG_pointers,
    NULL,
    NULL
  },
  "handle-set-message-user-tag",
  FALSE
};

static const _ExtendedGDBusArgInfo _egdbus_folder_method_info_get_parent_store_OUT_ARG_store =
{
  {
    -1,
    "store",
    "o",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _egdbus_folder_method_info_get_parent_store_OUT_ARG_pointers[] =
{
  &_egdbus_folder_method_info_get_parent_store_OUT_ARG_store,
  NULL
};

static const _ExtendedGDBusMethodInfo _egdbus_folder_method_info_get_parent_store =
{
  {
    -1,
    "getParentStore",
    NULL,
    (GDBusArgInfo **) &_egdbus_folder_method_info_get_parent_store_OUT_ARG_pointers,
    NULL
  },
  "handle-get-parent-store",
  FALSE
};

static const _ExtendedGDBusArgInfo _egdbus_folder_method_info_append_message_IN_ARG_info =
{
  {
    -1,
    "info",
    "(sssssssuutttiatasa(ss))",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _egdbus_folder_method_info_append_message_IN_ARG_message =
{
  {
    -1,
    "message",
    "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _egdbus_folder_method_info_append_message_IN_ARG_ops =
{
  {
    -1,
    "ops",
    "o",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _egdbus_folder_method_info_append_message_IN_ARG_pointers[] =
{
  &_egdbus_folder_method_info_append_message_IN_ARG_info,
  &_egdbus_folder_method_info_append_message_IN_ARG_message,
  &_egdbus_folder_method_info_append_message_IN_ARG_ops,
  NULL
};

static const _ExtendedGDBusArgInfo _egdbus_folder_method_info_append_message_OUT_ARG_appendeduid =
{
  {
    -1,
    "appendeduid",
    "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _egdbus_folder_method_info_append_message_OUT_ARG_success =
{
  {
    -1,
    "success",
    "b",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _egdbus_folder_method_info_append_message_OUT_ARG_pointers[] =
{
  &_egdbus_folder_method_info_append_message_OUT_ARG_appendeduid,
  &_egdbus_folder_method_info_append_message_OUT_ARG_success,
  NULL
};

static const GDBusAnnotationInfo _egdbus_folder_method_append_message_annotation_info_0 =
{
  -1,
  "com.trolltech.QtDBus.QtTypeName.In0",
  "CamelMessageInfoVariant",
  NULL
};

static const GDBusAnnotationInfo * const _egdbus_folder_method_append_message_annotation_info_pointers[] =
{
  &_egdbus_folder_method_append_message_annotation_info_0,
  NULL
};

static const _ExtendedGDBusMethodInfo _egdbus_folder_method_info_append_message =
{
  {
    -1,
    "AppendMessage",
    (GDBusArgInfo **) &_egdbus_folder_method_info_append_message_IN_ARG_pointers,
    (GDBusArgInfo **) &_egdbus_folder_method_info_append_message_OUT_ARG_pointers,
    (GDBusAnnotationInfo **) &_egdbus_folder_method_append_message_annotation_info_pointers
  },
  "handle-append-message",
  FALSE
};

static const _ExtendedGDBusArgInfo _egdbus_folder_method_info_get_uids_OUT_ARG_uids =
{
  {
    -1,
    "uids",
    "as",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _egdbus_folder_method_info_get_uids_OUT_ARG_pointers[] =
{
  &_egdbus_folder_method_info_get_uids_OUT_ARG_uids,
  NULL
};

static const _ExtendedGDBusMethodInfo _egdbus_folder_method_info_get_uids =
{
  {
    -1,
    "getUids",
    NULL,
    (GDBusArgInfo **) &_egdbus_folder_method_info_get_uids_OUT_ARG_pointers,
    NULL
  },
  "handle-get-uids",
  FALSE
};

static const _ExtendedGDBusArgInfo _egdbus_folder_method_info_get_message_IN_ARG_uid =
{
  {
    -1,
    "uid",
    "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _egdbus_folder_method_info_get_message_IN_ARG_ops =
{
  {
    -1,
    "ops",
    "o",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _egdbus_folder_method_info_get_message_IN_ARG_pointers[] =
{
  &_egdbus_folder_method_info_get_message_IN_ARG_uid,
  &_egdbus_folder_method_info_get_message_IN_ARG_ops,
  NULL
};

static const _ExtendedGDBusArgInfo _egdbus_folder_method_info_get_message_OUT_ARG_message =
{
  {
    -1,
    "message",
    "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _egdbus_folder_method_info_get_message_OUT_ARG_pointers[] =
{
  &_egdbus_folder_method_info_get_message_OUT_ARG_message,
  NULL
};

static const _ExtendedGDBusMethodInfo _egdbus_folder_method_info_get_message =
{
  {
    -1,
    "getMessage",
    (GDBusArgInfo **) &_egdbus_folder_method_info_get_message_IN_ARG_pointers,
    (GDBusArgInfo **) &_egdbus_folder_method_info_get_message_OUT_ARG_pointers,
    NULL
  },
  "handle-get-message",
  FALSE
};

static const _ExtendedGDBusArgInfo _egdbus_folder_method_info_get_quota_info_IN_ARG_ops =
{
  {
    -1,
    "ops",
    "o",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _egdbus_folder_method_info_get_quota_info_IN_ARG_pointers[] =
{
  &_egdbus_folder_method_info_get_quota_info_IN_ARG_ops,
  NULL
};

static const _ExtendedGDBusArgInfo _egdbus_folder_method_info_get_quota_info_OUT_ARG_quotainfo =
{
  {
    -1,
    "quotainfo",
    "a(stt)",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _egdbus_folder_method_info_get_quota_info_OUT_ARG_pointers[] =
{
  &_egdbus_folder_method_info_get_quota_info_OUT_ARG_quotainfo,
  NULL
};

static const _ExtendedGDBusMethodInfo _egdbus_folder_method_info_get_quota_info =
{
  {
    -1,
    "getQuotaInfo",
    (GDBusArgInfo **) &_egdbus_folder_method_info_get_quota_info_IN_ARG_pointers,
    (GDBusArgInfo **) &_egdbus_folder_method_info_get_quota_info_OUT_ARG_pointers,
    NULL
  },
  "handle-get-quota-info",
  FALSE
};

static const _ExtendedGDBusArgInfo _egdbus_folder_method_info_search_by_expression_IN_ARG_expression =
{
  {
    -1,
    "expression",
    "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _egdbus_folder_method_info_search_by_expression_IN_ARG_ops =
{
  {
    -1,
    "ops",
    "o",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _egdbus_folder_method_info_search_by_expression_IN_ARG_pointers[] =
{
  &_egdbus_folder_method_info_search_by_expression_IN_ARG_expression,
  &_egdbus_folder_method_info_search_by_expression_IN_ARG_ops,
  NULL
};

static const _ExtendedGDBusArgInfo _egdbus_folder_method_info_search_by_expression_OUT_ARG_uids =
{
  {
    -1,
    "uids",
    "as",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _egdbus_folder_method_info_search_by_expression_OUT_ARG_pointers[] =
{
  &_egdbus_folder_method_info_search_by_expression_OUT_ARG_uids,
  NULL
};

static const _ExtendedGDBusMethodInfo _egdbus_folder_method_info_search_by_expression =
{
  {
    -1,
    "searchByExpression",
    (GDBusArgInfo **) &_egdbus_folder_method_info_search_by_expression_IN_ARG_pointers,
    (GDBusArgInfo **) &_egdbus_folder_method_info_search_by_expression_OUT_ARG_pointers,
    NULL
  },
  "handle-search-by-expression",
  FALSE
};

static const _ExtendedGDBusArgInfo _egdbus_folder_method_info_search_sort_by_expression_IN_ARG_expression =
{
  {
    -1,
    "expression",
    "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _egdbus_folder_method_info_search_sort_by_expression_IN_ARG_sort =
{
  {
    -1,
    "sort",
    "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _egdbus_folder_method_info_search_sort_by_expression_IN_ARG_ascending =
{
  {
    -1,
    "ascending",
    "b",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _egdbus_folder_method_info_search_sort_by_expression_IN_ARG_ops =
{
  {
    -1,
    "ops",
    "o",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _egdbus_folder_method_info_search_sort_by_expression_IN_ARG_pointers[] =
{
  &_egdbus_folder_method_info_search_sort_by_expression_IN_ARG_expression,
  &_egdbus_folder_method_info_search_sort_by_expression_IN_ARG_sort,
  &_egdbus_folder_method_info_search_sort_by_expression_IN_ARG_ascending,
  &_egdbus_folder_method_info_search_sort_by_expression_IN_ARG_ops,
  NULL
};

static const _ExtendedGDBusArgInfo _egdbus_folder_method_info_search_sort_by_expression_OUT_ARG_uids =
{
  {
    -1,
    "uids",
    "as",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _egdbus_folder_method_info_search_sort_by_expression_OUT_ARG_pointers[] =
{
  &_egdbus_folder_method_info_search_sort_by_expression_OUT_ARG_uids,
  NULL
};

static const _ExtendedGDBusMethodInfo _egdbus_folder_method_info_search_sort_by_expression =
{
  {
    -1,
    "searchSortByExpression",
    (GDBusArgInfo **) &_egdbus_folder_method_info_search_sort_by_expression_IN_ARG_pointers,
    (GDBusArgInfo **) &_egdbus_folder_method_info_search_sort_by_expression_OUT_ARG_pointers,
    NULL
  },
  "handle-search-sort-by-expression",
  FALSE
};

static const _ExtendedGDBusArgInfo _egdbus_folder_method_info_search_by_uids_IN_ARG_expression =
{
  {
    -1,
    "expression",
    "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _egdbus_folder_method_info_search_by_uids_IN_ARG_searchuids =
{
  {
    -1,
    "searchuids",
    "as",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _egdbus_folder_method_info_search_by_uids_IN_ARG_ops =
{
  {
    -1,
    "ops",
    "o",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _egdbus_folder_method_info_search_by_uids_IN_ARG_pointers[] =
{
  &_egdbus_folder_method_info_search_by_uids_IN_ARG_expression,
  &_egdbus_folder_method_info_search_by_uids_IN_ARG_searchuids,
  &_egdbus_folder_method_info_search_by_uids_IN_ARG_ops,
  NULL
};

static const _ExtendedGDBusArgInfo _egdbus_folder_method_info_search_by_uids_OUT_ARG_resultuids =
{
  {
    -1,
    "resultuids",
    "as",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _egdbus_folder_method_info_search_by_uids_OUT_ARG_pointers[] =
{
  &_egdbus_folder_method_info_search_by_uids_OUT_ARG_resultuids,
  NULL
};

static const _ExtendedGDBusMethodInfo _egdbus_folder_method_info_search_by_uids =
{
  {
    -1,
    "searchByUids",
    (GDBusArgInfo **) &_egdbus_folder_method_info_search_by_uids_IN_ARG_pointers,
    (GDBusArgInfo **) &_egdbus_folder_method_info_search_by_uids_OUT_ARG_pointers,
    NULL
  },
  "handle-search-by-uids",
  FALSE
};

static const _ExtendedGDBusArgInfo _egdbus_folder_method_info_get_message_info_IN_ARG_uid =
{
  {
    -1,
    "uid",
    "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _egdbus_folder_method_info_get_message_info_IN_ARG_pointers[] =
{
  &_egdbus_folder_method_info_get_message_info_IN_ARG_uid,
  NULL
};

static const _ExtendedGDBusArgInfo _egdbus_folder_method_info_get_message_info_OUT_ARG_info =
{
  {
    -1,
    "info",
    "(sssssssuutttiatasa(ss))",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _egdbus_folder_method_info_get_message_info_OUT_ARG_pointers[] =
{
  &_egdbus_folder_method_info_get_message_info_OUT_ARG_info,
  NULL
};

static const GDBusAnnotationInfo _egdbus_folder_method_get_message_info_annotation_info_0 =
{
  -1,
  "com.trolltech.QtDBus.QtTypeName.Out0",
  "CamelMessageInfoVariant",
  NULL
};

static const GDBusAnnotationInfo * const _egdbus_folder_method_get_message_info_annotation_info_pointers[] =
{
  &_egdbus_folder_method_get_message_info_annotation_info_0,
  NULL
};

static const _ExtendedGDBusMethodInfo _egdbus_folder_method_info_get_message_info =
{
  {
    -1,
    "getMessageInfo",
    (GDBusArgInfo **) &_egdbus_folder_method_info_get_message_info_IN_ARG_pointers,
    (GDBusArgInfo **) &_egdbus_folder_method_info_get_message_info_OUT_ARG_pointers,
    (GDBusAnnotationInfo **) &_egdbus_folder_method_get_message_info_annotation_info_pointers
  },
  "handle-get-message-info",
  FALSE
};

static const _ExtendedGDBusArgInfo _egdbus_folder_method_info_transfer_messages_to_IN_ARG_uids =
{
  {
    -1,
    "uids",
    "as",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _egdbus_folder_method_info_transfer_messages_to_IN_ARG_destfolder =
{
  {
    -1,
    "destfolder",
    "o",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _egdbus_folder_method_info_transfer_messages_to_IN_ARG_deleteoriginals =
{
  {
    -1,
    "deleteoriginals",
    "b",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _egdbus_folder_method_info_transfer_messages_to_IN_ARG_ops =
{
  {
    -1,
    "ops",
    "o",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _egdbus_folder_method_info_transfer_messages_to_IN_ARG_pointers[] =
{
  &_egdbus_folder_method_info_transfer_messages_to_IN_ARG_uids,
  &_egdbus_folder_method_info_transfer_messages_to_IN_ARG_destfolder,
  &_egdbus_folder_method_info_transfer_messages_to_IN_ARG_deleteoriginals,
  &_egdbus_folder_method_info_transfer_messages_to_IN_ARG_ops,
  NULL
};

static const _ExtendedGDBusArgInfo _egdbus_folder_method_info_transfer_messages_to_OUT_ARG_returnuids =
{
  {
    -1,
    "returnuids",
    "as",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _egdbus_folder_method_info_transfer_messages_to_OUT_ARG_pointers[] =
{
  &_egdbus_folder_method_info_transfer_messages_to_OUT_ARG_returnuids,
  NULL
};

static const _ExtendedGDBusMethodInfo _egdbus_folder_method_info_transfer_messages_to =
{
  {
    -1,
    "transferMessagesTo",
    (GDBusArgInfo **) &_egdbus_folder_method_info_transfer_messages_to_IN_ARG_pointers,
    (GDBusArgInfo **) &_egdbus_folder_method_info_transfer_messages_to_OUT_ARG_pointers,
    NULL
  },
  "handle-transfer-messages-to",
  FALSE
};

static const _ExtendedGDBusArgInfo _egdbus_folder_method_info_prepare_summary_IN_ARG_ops =
{
  {
    -1,
    "ops",
    "o",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _egdbus_folder_method_info_prepare_summary_IN_ARG_pointers[] =
{
  &_egdbus_folder_method_info_prepare_summary_IN_ARG_ops,
  NULL
};

static const _ExtendedGDBusMethodInfo _egdbus_folder_method_info_prepare_summary =
{
  {
    -1,
    "prepareSummary",
    (GDBusArgInfo **) &_egdbus_folder_method_info_prepare_summary_IN_ARG_pointers,
    NULL,
    NULL
  },
  "handle-prepare-summary",
  FALSE
};

static const _ExtendedGDBusArgInfo _egdbus_folder_method_info_freeze_folder_IN_ARG_ops =
{
  {
    -1,
    "ops",
    "o",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _egdbus_folder_method_info_freeze_folder_IN_ARG_pointers[] =
{
  &_egdbus_folder_method_info_freeze_folder_IN_ARG_ops,
  NULL
};

static const _ExtendedGDBusMethodInfo _egdbus_folder_method_info_freeze_folder =
{
  {
    -1,
    "freezeFolder",
    (GDBusArgInfo **) &_egdbus_folder_method_info_freeze_folder_IN_ARG_pointers,
    NULL,
    NULL
  },
  "handle-freeze-folder",
  FALSE
};

static const _ExtendedGDBusArgInfo _egdbus_folder_method_info_thaw_folder_IN_ARG_ops =
{
  {
    -1,
    "ops",
    "o",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _egdbus_folder_method_info_thaw_folder_IN_ARG_pointers[] =
{
  &_egdbus_folder_method_info_thaw_folder_IN_ARG_ops,
  NULL
};

static const _ExtendedGDBusMethodInfo _egdbus_folder_method_info_thaw_folder =
{
  {
    -1,
    "thawFolder",
    (GDBusArgInfo **) &_egdbus_folder_method_info_thaw_folder_IN_ARG_pointers,
    NULL,
    NULL
  },
  "handle-thaw-folder",
  FALSE
};

static const _ExtendedGDBusMethodInfo * const _egdbus_folder_method_info_pointers[] =
{
  &_egdbus_folder_method_info_refresh_info,
  &_egdbus_folder_method_info_sync,
  &_egdbus_folder_method_info_sync_message,
  &_egdbus_folder_method_info_expunge,
  &_egdbus_folder_method_info_get_display_name,
  &_egdbus_folder_method_info_set_display_name,
  &_egdbus_folder_method_info_get_full_name,
  &_egdbus_folder_method_info_set_full_name,
  &_egdbus_folder_method_info_get_description,
  &_egdbus_folder_method_info_set_description,
  &_egdbus_folder_method_info_get_permanent_flags,
  &_egdbus_folder_method_info_has_summary_capability,
  &_egdbus_folder_method_info_has_search_capability,
  &_egdbus_folder_method_info_total_message_count,
  &_egdbus_folder_method_info_unread_message_count,
  &_egdbus_folder_method_info_deleted_message_count,
  &_egdbus_folder_method_info_get_message_flags,
  &_egdbus_folder_method_info_set_message_flags,
  &_egdbus_folder_method_info_get_message_user_flag,
  &_egdbus_folder_method_info_set_message_user_flag,
  &_egdbus_folder_method_info_get_message_user_tag,
  &_egdbus_folder_method_info_set_message_user_tag,
  &_egdbus_folder_method_info_get_parent_store,
  &_egdbus_folder_method_info_append_message,
  &_egdbus_folder_method_info_get_uids,
  &_egdbus_folder_method_info_get_message,
  &_egdbus_folder_method_info_get_quota_info,
  &_egdbus_folder_method_info_search_by_expression,
  &_egdbus_folder_method_info_search_sort_by_expression,
  &_egdbus_folder_method_info_search_by_uids,
  &_egdbus_folder_method_info_get_message_info,
  &_egdbus_folder_method_info_transfer_messages_to,
  &_egdbus_folder_method_info_prepare_summary,
  &_egdbus_folder_method_info_freeze_folder,
  &_egdbus_folder_method_info_thaw_folder,
  NULL
};

static const _ExtendedGDBusArgInfo _egdbus_folder_signal_info_folder_changed_ARG_uids_added =
{
  {
    -1,
    "uids_added",
    "as",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _egdbus_folder_signal_info_folder_changed_ARG_uids_removed =
{
  {
    -1,
    "uids_removed",
    "as",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _egdbus_folder_signal_info_folder_changed_ARG_uids_changed =
{
  {
    -1,
    "uids_changed",
    "as",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _egdbus_folder_signal_info_folder_changed_ARG_uids_recent =
{
  {
    -1,
    "uids_recent",
    "as",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _egdbus_folder_signal_info_folder_changed_ARG_pointers[] =
{
  &_egdbus_folder_signal_info_folder_changed_ARG_uids_added,
  &_egdbus_folder_signal_info_folder_changed_ARG_uids_removed,
  &_egdbus_folder_signal_info_folder_changed_ARG_uids_changed,
  &_egdbus_folder_signal_info_folder_changed_ARG_uids_recent,
  NULL
};

static const _ExtendedGDBusSignalInfo _egdbus_folder_signal_info_folder_changed =
{
  {
    -1,
    "FolderChanged",
    (GDBusArgInfo **) &_egdbus_folder_signal_info_folder_changed_ARG_pointers,
    NULL
  },
  "folder-changed"
};

static const _ExtendedGDBusSignalInfo * const _egdbus_folder_signal_info_pointers[] =
{
  &_egdbus_folder_signal_info_folder_changed,
  NULL
};

static const GDBusAnnotationInfo _egdbus_folder_annotation_info_0 =
{
  -1,
  "org.freedesktop.DBus.GLib.CSymbol",
  "EMailDataFolder",
  NULL
};

static const GDBusAnnotationInfo * const _egdbus_folder_annotation_info_pointers[] =
{
  &_egdbus_folder_annotation_info_0,
  NULL
};

static const _ExtendedGDBusInterfaceInfo _egdbus_folder_interface_info =
{
  {
    -1,
    "org.gnome.evolution.dataserver.mail.Folder",
    (GDBusMethodInfo **) &_egdbus_folder_method_info_pointers,
    (GDBusSignalInfo **) &_egdbus_folder_signal_info_pointers,
    NULL,
    (GDBusAnnotationInfo **) &_egdbus_folder_annotation_info_pointers
  },
  "folder",
};


/**
 * egdbus_folder_interface_info:
 *
 * Gets a machine-readable description of the <link linkend="gdbus-interface-org-gnome-evolution-dataserver-mail-Folder.top_of_page">org.gnome.evolution.dataserver.mail.Folder</link> D-Bus interface.
 *
 * Returns: (transfer none): A #GDBusInterfaceInfo. Do not free.
 */
GDBusInterfaceInfo *
egdbus_folder_interface_info (void)
{
  return (GDBusInterfaceInfo *) &_egdbus_folder_interface_info;
}

/**
 * egdbus_folder_override_properties:
 * @klass: The class structure for a #GObject<!-- -->-derived class.
 * @property_id_begin: The property id to assign to the first overridden property.
 *
 * Overrides all #GObject properties in the #EGdbusFolder interface for a concrete class.
 * The properties are overridden in the order they are defined.
 *
 * Returns: The last property id.
 */
guint
egdbus_folder_override_properties (GObjectClass *klass, guint property_id_begin)
{
  return property_id_begin - 1;
}



/**
 * EGdbusFolder:
 *
 * Abstract interface type for the D-Bus interface <link linkend="gdbus-interface-org-gnome-evolution-dataserver-mail-Folder.top_of_page">org.gnome.evolution.dataserver.mail.Folder</link>.
 */

/**
 * EGdbusFolderIface:
 * @parent_iface: The parent interface.
 * @handle_append_message: Handler for the #EGdbusFolder::handle-append-message signal.
 * @handle_deleted_message_count: Handler for the #EGdbusFolder::handle-deleted-message-count signal.
 * @handle_expunge: Handler for the #EGdbusFolder::handle-expunge signal.
 * @handle_freeze_folder: Handler for the #EGdbusFolder::handle-freeze-folder signal.
 * @handle_get_description: Handler for the #EGdbusFolder::handle-get-description signal.
 * @handle_get_display_name: Handler for the #EGdbusFolder::handle-get-display-name signal.
 * @handle_get_full_name: Handler for the #EGdbusFolder::handle-get-full-name signal.
 * @handle_get_message: Handler for the #EGdbusFolder::handle-get-message signal.
 * @handle_get_message_flags: Handler for the #EGdbusFolder::handle-get-message-flags signal.
 * @handle_get_message_info: Handler for the #EGdbusFolder::handle-get-message-info signal.
 * @handle_get_message_user_flag: Handler for the #EGdbusFolder::handle-get-message-user-flag signal.
 * @handle_get_message_user_tag: Handler for the #EGdbusFolder::handle-get-message-user-tag signal.
 * @handle_get_parent_store: Handler for the #EGdbusFolder::handle-get-parent-store signal.
 * @handle_get_permanent_flags: Handler for the #EGdbusFolder::handle-get-permanent-flags signal.
 * @handle_get_quota_info: Handler for the #EGdbusFolder::handle-get-quota-info signal.
 * @handle_get_uids: Handler for the #EGdbusFolder::handle-get-uids signal.
 * @handle_has_search_capability: Handler for the #EGdbusFolder::handle-has-search-capability signal.
 * @handle_has_summary_capability: Handler for the #EGdbusFolder::handle-has-summary-capability signal.
 * @handle_prepare_summary: Handler for the #EGdbusFolder::handle-prepare-summary signal.
 * @handle_refresh_info: Handler for the #EGdbusFolder::handle-refresh-info signal.
 * @handle_search_by_expression: Handler for the #EGdbusFolder::handle-search-by-expression signal.
 * @handle_search_by_uids: Handler for the #EGdbusFolder::handle-search-by-uids signal.
 * @handle_search_sort_by_expression: Handler for the #EGdbusFolder::handle-search-sort-by-expression signal.
 * @handle_set_description: Handler for the #EGdbusFolder::handle-set-description signal.
 * @handle_set_display_name: Handler for the #EGdbusFolder::handle-set-display-name signal.
 * @handle_set_full_name: Handler for the #EGdbusFolder::handle-set-full-name signal.
 * @handle_set_message_flags: Handler for the #EGdbusFolder::handle-set-message-flags signal.
 * @handle_set_message_user_flag: Handler for the #EGdbusFolder::handle-set-message-user-flag signal.
 * @handle_set_message_user_tag: Handler for the #EGdbusFolder::handle-set-message-user-tag signal.
 * @handle_sync: Handler for the #EGdbusFolder::handle-sync signal.
 * @handle_sync_message: Handler for the #EGdbusFolder::handle-sync-message signal.
 * @handle_thaw_folder: Handler for the #EGdbusFolder::handle-thaw-folder signal.
 * @handle_total_message_count: Handler for the #EGdbusFolder::handle-total-message-count signal.
 * @handle_transfer_messages_to: Handler for the #EGdbusFolder::handle-transfer-messages-to signal.
 * @handle_unread_message_count: Handler for the #EGdbusFolder::handle-unread-message-count signal.
 * @folder_changed: Handler for the #EGdbusFolder::folder-changed signal.
 *
 * Virtual table for the D-Bus interface <link linkend="gdbus-interface-org-gnome-evolution-dataserver-mail-Folder.top_of_page">org.gnome.evolution.dataserver.mail.Folder</link>.
 */

static void
egdbus_folder_default_init (EGdbusFolderIface *iface)
{
  /* GObject signals for incoming D-Bus method calls: */
  /**
   * EGdbusFolder::handle-refresh-info:
   * @object: A #EGdbusFolder.
   * @invocation: A #GDBusMethodInvocation.
   * @arg_ops: Argument passed by remote caller.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.refreshInfo">refreshInfo()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call egdbus_folder_complete_refresh_info() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-refresh-info",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (EGdbusFolderIface, handle_refresh_info),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    2,
    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_STRING);

  /**
   * EGdbusFolder::handle-sync:
   * @object: A #EGdbusFolder.
   * @invocation: A #GDBusMethodInvocation.
   * @arg_expunge: Argument passed by remote caller.
   * @arg_ops: Argument passed by remote caller.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.sync">sync()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call egdbus_folder_complete_sync() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-sync",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (EGdbusFolderIface, handle_sync),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    3,
    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_BOOLEAN, G_TYPE_STRING);

  /**
   * EGdbusFolder::handle-sync-message:
   * @object: A #EGdbusFolder.
   * @invocation: A #GDBusMethodInvocation.
   * @arg_uid: Argument passed by remote caller.
   * @arg_ops: Argument passed by remote caller.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.syncMessage">syncMessage()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call egdbus_folder_complete_sync_message() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-sync-message",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (EGdbusFolderIface, handle_sync_message),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    3,
    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_STRING, G_TYPE_STRING);

  /**
   * EGdbusFolder::handle-expunge:
   * @object: A #EGdbusFolder.
   * @invocation: A #GDBusMethodInvocation.
   * @arg_ops: Argument passed by remote caller.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.expunge">expunge()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call egdbus_folder_complete_expunge() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-expunge",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (EGdbusFolderIface, handle_expunge),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    2,
    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_STRING);

  /**
   * EGdbusFolder::handle-get-display-name:
   * @object: A #EGdbusFolder.
   * @invocation: A #GDBusMethodInvocation.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.getDisplayName">getDisplayName()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call egdbus_folder_complete_get_display_name() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-get-display-name",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (EGdbusFolderIface, handle_get_display_name),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    1,
    G_TYPE_DBUS_METHOD_INVOCATION);

  /**
   * EGdbusFolder::handle-set-display-name:
   * @object: A #EGdbusFolder.
   * @invocation: A #GDBusMethodInvocation.
   * @arg_name: Argument passed by remote caller.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.setDisplayName">setDisplayName()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call egdbus_folder_complete_set_display_name() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-set-display-name",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (EGdbusFolderIface, handle_set_display_name),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    2,
    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_STRING);

  /**
   * EGdbusFolder::handle-get-full-name:
   * @object: A #EGdbusFolder.
   * @invocation: A #GDBusMethodInvocation.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.getFullName">getFullName()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call egdbus_folder_complete_get_full_name() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-get-full-name",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (EGdbusFolderIface, handle_get_full_name),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    1,
    G_TYPE_DBUS_METHOD_INVOCATION);

  /**
   * EGdbusFolder::handle-set-full-name:
   * @object: A #EGdbusFolder.
   * @invocation: A #GDBusMethodInvocation.
   * @arg_name: Argument passed by remote caller.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.setFullName">setFullName()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call egdbus_folder_complete_set_full_name() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-set-full-name",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (EGdbusFolderIface, handle_set_full_name),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    2,
    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_STRING);

  /**
   * EGdbusFolder::handle-get-description:
   * @object: A #EGdbusFolder.
   * @invocation: A #GDBusMethodInvocation.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.getDescription">getDescription()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call egdbus_folder_complete_get_description() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-get-description",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (EGdbusFolderIface, handle_get_description),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    1,
    G_TYPE_DBUS_METHOD_INVOCATION);

  /**
   * EGdbusFolder::handle-set-description:
   * @object: A #EGdbusFolder.
   * @invocation: A #GDBusMethodInvocation.
   * @arg_desc: Argument passed by remote caller.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.setDescription">setDescription()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call egdbus_folder_complete_set_description() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-set-description",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (EGdbusFolderIface, handle_set_description),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    2,
    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_STRING);

  /**
   * EGdbusFolder::handle-get-permanent-flags:
   * @object: A #EGdbusFolder.
   * @invocation: A #GDBusMethodInvocation.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.getPermanentFlags">getPermanentFlags()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call egdbus_folder_complete_get_permanent_flags() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-get-permanent-flags",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (EGdbusFolderIface, handle_get_permanent_flags),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    1,
    G_TYPE_DBUS_METHOD_INVOCATION);

  /**
   * EGdbusFolder::handle-has-summary-capability:
   * @object: A #EGdbusFolder.
   * @invocation: A #GDBusMethodInvocation.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.hasSummaryCapability">hasSummaryCapability()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call egdbus_folder_complete_has_summary_capability() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-has-summary-capability",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (EGdbusFolderIface, handle_has_summary_capability),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    1,
    G_TYPE_DBUS_METHOD_INVOCATION);

  /**
   * EGdbusFolder::handle-has-search-capability:
   * @object: A #EGdbusFolder.
   * @invocation: A #GDBusMethodInvocation.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.hasSearchCapability">hasSearchCapability()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call egdbus_folder_complete_has_search_capability() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-has-search-capability",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (EGdbusFolderIface, handle_has_search_capability),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    1,
    G_TYPE_DBUS_METHOD_INVOCATION);

  /**
   * EGdbusFolder::handle-total-message-count:
   * @object: A #EGdbusFolder.
   * @invocation: A #GDBusMethodInvocation.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.totalMessageCount">totalMessageCount()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call egdbus_folder_complete_total_message_count() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-total-message-count",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (EGdbusFolderIface, handle_total_message_count),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    1,
    G_TYPE_DBUS_METHOD_INVOCATION);

  /**
   * EGdbusFolder::handle-unread-message-count:
   * @object: A #EGdbusFolder.
   * @invocation: A #GDBusMethodInvocation.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.unreadMessageCount">unreadMessageCount()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call egdbus_folder_complete_unread_message_count() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-unread-message-count",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (EGdbusFolderIface, handle_unread_message_count),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    1,
    G_TYPE_DBUS_METHOD_INVOCATION);

  /**
   * EGdbusFolder::handle-deleted-message-count:
   * @object: A #EGdbusFolder.
   * @invocation: A #GDBusMethodInvocation.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.deletedMessageCount">deletedMessageCount()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call egdbus_folder_complete_deleted_message_count() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-deleted-message-count",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (EGdbusFolderIface, handle_deleted_message_count),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    1,
    G_TYPE_DBUS_METHOD_INVOCATION);

  /**
   * EGdbusFolder::handle-get-message-flags:
   * @object: A #EGdbusFolder.
   * @invocation: A #GDBusMethodInvocation.
   * @arg_uid: Argument passed by remote caller.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.getMessageFlags">getMessageFlags()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call egdbus_folder_complete_get_message_flags() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-get-message-flags",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (EGdbusFolderIface, handle_get_message_flags),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    2,
    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_STRING);

  /**
   * EGdbusFolder::handle-set-message-flags:
   * @object: A #EGdbusFolder.
   * @invocation: A #GDBusMethodInvocation.
   * @arg_uid: Argument passed by remote caller.
   * @arg_flags: Argument passed by remote caller.
   * @arg_set: Argument passed by remote caller.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.setMessageFlags">setMessageFlags()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call egdbus_folder_complete_set_message_flags() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-set-message-flags",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (EGdbusFolderIface, handle_set_message_flags),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    4,
    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_STRING, G_TYPE_UINT, G_TYPE_UINT);

  /**
   * EGdbusFolder::handle-get-message-user-flag:
   * @object: A #EGdbusFolder.
   * @invocation: A #GDBusMethodInvocation.
   * @arg_uid: Argument passed by remote caller.
   * @arg_flagname: Argument passed by remote caller.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.getMessageUserFlag">getMessageUserFlag()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call egdbus_folder_complete_get_message_user_flag() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-get-message-user-flag",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (EGdbusFolderIface, handle_get_message_user_flag),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    3,
    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_STRING, G_TYPE_STRING);

  /**
   * EGdbusFolder::handle-set-message-user-flag:
   * @object: A #EGdbusFolder.
   * @invocation: A #GDBusMethodInvocation.
   * @arg_uid: Argument passed by remote caller.
   * @arg_flagname: Argument passed by remote caller.
   * @arg_set: Argument passed by remote caller.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.setMessageUserFlag">setMessageUserFlag()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call egdbus_folder_complete_set_message_user_flag() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-set-message-user-flag",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (EGdbusFolderIface, handle_set_message_user_flag),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    4,
    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_STRING, G_TYPE_STRING, G_TYPE_UINT);

  /**
   * EGdbusFolder::handle-get-message-user-tag:
   * @object: A #EGdbusFolder.
   * @invocation: A #GDBusMethodInvocation.
   * @arg_uid: Argument passed by remote caller.
   * @arg_param: Argument passed by remote caller.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.getMessageUserTag">getMessageUserTag()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call egdbus_folder_complete_get_message_user_tag() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-get-message-user-tag",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (EGdbusFolderIface, handle_get_message_user_tag),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    3,
    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_STRING, G_TYPE_STRING);

  /**
   * EGdbusFolder::handle-set-message-user-tag:
   * @object: A #EGdbusFolder.
   * @invocation: A #GDBusMethodInvocation.
   * @arg_uid: Argument passed by remote caller.
   * @arg_param: Argument passed by remote caller.
   * @arg_value: Argument passed by remote caller.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.setMessageUserTag">setMessageUserTag()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call egdbus_folder_complete_set_message_user_tag() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-set-message-user-tag",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (EGdbusFolderIface, handle_set_message_user_tag),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    4,
    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_STRING, G_TYPE_STRING, G_TYPE_STRING);

  /**
   * EGdbusFolder::handle-get-parent-store:
   * @object: A #EGdbusFolder.
   * @invocation: A #GDBusMethodInvocation.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.getParentStore">getParentStore()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call egdbus_folder_complete_get_parent_store() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-get-parent-store",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (EGdbusFolderIface, handle_get_parent_store),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    1,
    G_TYPE_DBUS_METHOD_INVOCATION);

  /**
   * EGdbusFolder::handle-append-message:
   * @object: A #EGdbusFolder.
   * @invocation: A #GDBusMethodInvocation.
   * @arg_info: Argument passed by remote caller.
   * @arg_message: Argument passed by remote caller.
   * @arg_ops: Argument passed by remote caller.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.AppendMessage">AppendMessage()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call egdbus_folder_complete_append_message() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-append-message",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (EGdbusFolderIface, handle_append_message),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    4,
    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_VARIANT, G_TYPE_STRING, G_TYPE_STRING);

  /**
   * EGdbusFolder::handle-get-uids:
   * @object: A #EGdbusFolder.
   * @invocation: A #GDBusMethodInvocation.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.getUids">getUids()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call egdbus_folder_complete_get_uids() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-get-uids",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (EGdbusFolderIface, handle_get_uids),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    1,
    G_TYPE_DBUS_METHOD_INVOCATION);

  /**
   * EGdbusFolder::handle-get-message:
   * @object: A #EGdbusFolder.
   * @invocation: A #GDBusMethodInvocation.
   * @arg_uid: Argument passed by remote caller.
   * @arg_ops: Argument passed by remote caller.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.getMessage">getMessage()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call egdbus_folder_complete_get_message() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-get-message",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (EGdbusFolderIface, handle_get_message),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    3,
    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_STRING, G_TYPE_STRING);

  /**
   * EGdbusFolder::handle-get-quota-info:
   * @object: A #EGdbusFolder.
   * @invocation: A #GDBusMethodInvocation.
   * @arg_ops: Argument passed by remote caller.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.getQuotaInfo">getQuotaInfo()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call egdbus_folder_complete_get_quota_info() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-get-quota-info",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (EGdbusFolderIface, handle_get_quota_info),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    2,
    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_STRING);

  /**
   * EGdbusFolder::handle-search-by-expression:
   * @object: A #EGdbusFolder.
   * @invocation: A #GDBusMethodInvocation.
   * @arg_expression: Argument passed by remote caller.
   * @arg_ops: Argument passed by remote caller.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.searchByExpression">searchByExpression()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call egdbus_folder_complete_search_by_expression() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-search-by-expression",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (EGdbusFolderIface, handle_search_by_expression),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    3,
    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_STRING, G_TYPE_STRING);

  /**
   * EGdbusFolder::handle-search-sort-by-expression:
   * @object: A #EGdbusFolder.
   * @invocation: A #GDBusMethodInvocation.
   * @arg_expression: Argument passed by remote caller.
   * @arg_sort: Argument passed by remote caller.
   * @arg_ascending: Argument passed by remote caller.
   * @arg_ops: Argument passed by remote caller.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.searchSortByExpression">searchSortByExpression()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call egdbus_folder_complete_search_sort_by_expression() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-search-sort-by-expression",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (EGdbusFolderIface, handle_search_sort_by_expression),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    5,
    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_STRING, G_TYPE_STRING, G_TYPE_BOOLEAN, G_TYPE_STRING);

  /**
   * EGdbusFolder::handle-search-by-uids:
   * @object: A #EGdbusFolder.
   * @invocation: A #GDBusMethodInvocation.
   * @arg_expression: Argument passed by remote caller.
   * @arg_searchuids: Argument passed by remote caller.
   * @arg_ops: Argument passed by remote caller.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.searchByUids">searchByUids()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call egdbus_folder_complete_search_by_uids() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-search-by-uids",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (EGdbusFolderIface, handle_search_by_uids),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    4,
    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_STRING, G_TYPE_STRV, G_TYPE_STRING);

  /**
   * EGdbusFolder::handle-get-message-info:
   * @object: A #EGdbusFolder.
   * @invocation: A #GDBusMethodInvocation.
   * @arg_uid: Argument passed by remote caller.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.getMessageInfo">getMessageInfo()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call egdbus_folder_complete_get_message_info() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-get-message-info",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (EGdbusFolderIface, handle_get_message_info),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    2,
    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_STRING);

  /**
   * EGdbusFolder::handle-transfer-messages-to:
   * @object: A #EGdbusFolder.
   * @invocation: A #GDBusMethodInvocation.
   * @arg_uids: Argument passed by remote caller.
   * @arg_destfolder: Argument passed by remote caller.
   * @arg_deleteoriginals: Argument passed by remote caller.
   * @arg_ops: Argument passed by remote caller.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.transferMessagesTo">transferMessagesTo()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call egdbus_folder_complete_transfer_messages_to() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-transfer-messages-to",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (EGdbusFolderIface, handle_transfer_messages_to),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    5,
    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_STRV, G_TYPE_STRING, G_TYPE_BOOLEAN, G_TYPE_STRING);

  /**
   * EGdbusFolder::handle-prepare-summary:
   * @object: A #EGdbusFolder.
   * @invocation: A #GDBusMethodInvocation.
   * @arg_ops: Argument passed by remote caller.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.prepareSummary">prepareSummary()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call egdbus_folder_complete_prepare_summary() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-prepare-summary",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (EGdbusFolderIface, handle_prepare_summary),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    2,
    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_STRING);

  /**
   * EGdbusFolder::handle-freeze-folder:
   * @object: A #EGdbusFolder.
   * @invocation: A #GDBusMethodInvocation.
   * @arg_ops: Argument passed by remote caller.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.freezeFolder">freezeFolder()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call egdbus_folder_complete_freeze_folder() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-freeze-folder",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (EGdbusFolderIface, handle_freeze_folder),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    2,
    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_STRING);

  /**
   * EGdbusFolder::handle-thaw-folder:
   * @object: A #EGdbusFolder.
   * @invocation: A #GDBusMethodInvocation.
   * @arg_ops: Argument passed by remote caller.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.thawFolder">thawFolder()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call egdbus_folder_complete_thaw_folder() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-thaw-folder",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (EGdbusFolderIface, handle_thaw_folder),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    2,
    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_STRING);

  /* GObject signals for received D-Bus signals: */
  /**
   * EGdbusFolder::folder-changed:
   * @object: A #EGdbusFolder.
   * @arg_uids_added: Argument.
   * @arg_uids_removed: Argument.
   * @arg_uids_changed: Argument.
   * @arg_uids_recent: Argument.
   *
   * On the client-side, this signal is emitted whenever the D-Bus signal <link linkend="gdbus-signal-org-gnome-evolution-dataserver-mail-Folder.FolderChanged">"FolderChanged"</link> is received.
   *
   * On the service-side, this signal can be used with e.g. g_signal_emit_by_name() to make the object emit the D-Bus signal.
   */
  g_signal_new ("folder-changed",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (EGdbusFolderIface, folder_changed),
    NULL,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_NONE,
    4, G_TYPE_STRV, G_TYPE_STRV, G_TYPE_STRV, G_TYPE_STRV);

}

typedef EGdbusFolderIface EGdbusFolderInterface;
G_DEFINE_INTERFACE (EGdbusFolder, egdbus_folder, G_TYPE_OBJECT);

/**
 * egdbus_folder_emit_folder_changed:
 * @object: A #EGdbusFolder.
 * @arg_uids_added: Argument to pass with the signal.
 * @arg_uids_removed: Argument to pass with the signal.
 * @arg_uids_changed: Argument to pass with the signal.
 * @arg_uids_recent: Argument to pass with the signal.
 *
 * Emits the <link linkend="gdbus-signal-org-gnome-evolution-dataserver-mail-Folder.FolderChanged">"FolderChanged"</link> D-Bus signal.
 */
void
egdbus_folder_emit_folder_changed (
    EGdbusFolder *object,
    const gchar *const *arg_uids_added,
    const gchar *const *arg_uids_removed,
    const gchar *const *arg_uids_changed,
    const gchar *const *arg_uids_recent)
{
  g_signal_emit_by_name (object, "folder-changed", arg_uids_added, arg_uids_removed, arg_uids_changed, arg_uids_recent);
}

/**
 * egdbus_folder_call_refresh_info:
 * @proxy: A #EGdbusFolderProxy.
 * @arg_ops: Argument to pass with the method invocation.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.refreshInfo">refreshInfo()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call egdbus_folder_call_refresh_info_finish() to get the result of the operation.
 *
 * See egdbus_folder_call_refresh_info_sync() for the synchronous, blocking version of this method.
 */
void
egdbus_folder_call_refresh_info (
    EGdbusFolder *proxy,
    const gchar *arg_ops,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "refreshInfo",
    g_variant_new ("(o)",
                   arg_ops),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * egdbus_folder_call_refresh_info_finish:
 * @proxy: A #EGdbusFolderProxy.
 * @out_success: (out): Return location for return parameter or %NULL to ignore.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to egdbus_folder_call_refresh_info().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with egdbus_folder_call_refresh_info().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
egdbus_folder_call_refresh_info_finish (
    EGdbusFolder *proxy,
    gboolean *out_success,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(b)",
                 out_success);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * egdbus_folder_call_refresh_info_sync:
 * @proxy: A #EGdbusFolderProxy.
 * @arg_ops: Argument to pass with the method invocation.
 * @out_success: (out): Return location for return parameter or %NULL to ignore.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.refreshInfo">refreshInfo()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See egdbus_folder_call_refresh_info() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
egdbus_folder_call_refresh_info_sync (
    EGdbusFolder *proxy,
    const gchar *arg_ops,
    gboolean *out_success,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "refreshInfo",
    g_variant_new ("(o)",
                   arg_ops),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(b)",
                 out_success);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * egdbus_folder_call_sync:
 * @proxy: A #EGdbusFolderProxy.
 * @arg_expunge: Argument to pass with the method invocation.
 * @arg_ops: Argument to pass with the method invocation.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.sync">sync()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call egdbus_folder_call_sync_finish() to get the result of the operation.
 *
 * See egdbus_folder_call_sync_sync() for the synchronous, blocking version of this method.
 */
void
egdbus_folder_call_sync (
    EGdbusFolder *proxy,
    gboolean arg_expunge,
    const gchar *arg_ops,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "sync",
    g_variant_new ("(bo)",
                   arg_expunge,
                   arg_ops),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * egdbus_folder_call_sync_finish:
 * @proxy: A #EGdbusFolderProxy.
 * @out_success: (out): Return location for return parameter or %NULL to ignore.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to egdbus_folder_call_sync().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with egdbus_folder_call_sync().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
egdbus_folder_call_sync_finish (
    EGdbusFolder *proxy,
    gboolean *out_success,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(b)",
                 out_success);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * egdbus_folder_call_sync_sync:
 * @proxy: A #EGdbusFolderProxy.
 * @arg_expunge: Argument to pass with the method invocation.
 * @arg_ops: Argument to pass with the method invocation.
 * @out_success: (out): Return location for return parameter or %NULL to ignore.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.sync">sync()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See egdbus_folder_call_sync() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
egdbus_folder_call_sync_sync (
    EGdbusFolder *proxy,
    gboolean arg_expunge,
    const gchar *arg_ops,
    gboolean *out_success,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "sync",
    g_variant_new ("(bo)",
                   arg_expunge,
                   arg_ops),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(b)",
                 out_success);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * egdbus_folder_call_sync_message:
 * @proxy: A #EGdbusFolderProxy.
 * @arg_uid: Argument to pass with the method invocation.
 * @arg_ops: Argument to pass with the method invocation.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.syncMessage">syncMessage()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call egdbus_folder_call_sync_message_finish() to get the result of the operation.
 *
 * See egdbus_folder_call_sync_message_sync() for the synchronous, blocking version of this method.
 */
void
egdbus_folder_call_sync_message (
    EGdbusFolder *proxy,
    const gchar *arg_uid,
    const gchar *arg_ops,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "syncMessage",
    g_variant_new ("(so)",
                   arg_uid,
                   arg_ops),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * egdbus_folder_call_sync_message_finish:
 * @proxy: A #EGdbusFolderProxy.
 * @out_success: (out): Return location for return parameter or %NULL to ignore.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to egdbus_folder_call_sync_message().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with egdbus_folder_call_sync_message().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
egdbus_folder_call_sync_message_finish (
    EGdbusFolder *proxy,
    gboolean *out_success,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(b)",
                 out_success);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * egdbus_folder_call_sync_message_sync:
 * @proxy: A #EGdbusFolderProxy.
 * @arg_uid: Argument to pass with the method invocation.
 * @arg_ops: Argument to pass with the method invocation.
 * @out_success: (out): Return location for return parameter or %NULL to ignore.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.syncMessage">syncMessage()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See egdbus_folder_call_sync_message() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
egdbus_folder_call_sync_message_sync (
    EGdbusFolder *proxy,
    const gchar *arg_uid,
    const gchar *arg_ops,
    gboolean *out_success,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "syncMessage",
    g_variant_new ("(so)",
                   arg_uid,
                   arg_ops),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(b)",
                 out_success);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * egdbus_folder_call_expunge:
 * @proxy: A #EGdbusFolderProxy.
 * @arg_ops: Argument to pass with the method invocation.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.expunge">expunge()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call egdbus_folder_call_expunge_finish() to get the result of the operation.
 *
 * See egdbus_folder_call_expunge_sync() for the synchronous, blocking version of this method.
 */
void
egdbus_folder_call_expunge (
    EGdbusFolder *proxy,
    const gchar *arg_ops,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "expunge",
    g_variant_new ("(o)",
                   arg_ops),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * egdbus_folder_call_expunge_finish:
 * @proxy: A #EGdbusFolderProxy.
 * @out_success: (out): Return location for return parameter or %NULL to ignore.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to egdbus_folder_call_expunge().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with egdbus_folder_call_expunge().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
egdbus_folder_call_expunge_finish (
    EGdbusFolder *proxy,
    gboolean *out_success,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(b)",
                 out_success);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * egdbus_folder_call_expunge_sync:
 * @proxy: A #EGdbusFolderProxy.
 * @arg_ops: Argument to pass with the method invocation.
 * @out_success: (out): Return location for return parameter or %NULL to ignore.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.expunge">expunge()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See egdbus_folder_call_expunge() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
egdbus_folder_call_expunge_sync (
    EGdbusFolder *proxy,
    const gchar *arg_ops,
    gboolean *out_success,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "expunge",
    g_variant_new ("(o)",
                   arg_ops),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(b)",
                 out_success);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * egdbus_folder_call_get_display_name:
 * @proxy: A #EGdbusFolderProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.getDisplayName">getDisplayName()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call egdbus_folder_call_get_display_name_finish() to get the result of the operation.
 *
 * See egdbus_folder_call_get_display_name_sync() for the synchronous, blocking version of this method.
 */
void
egdbus_folder_call_get_display_name (
    EGdbusFolder *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "getDisplayName",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * egdbus_folder_call_get_display_name_finish:
 * @proxy: A #EGdbusFolderProxy.
 * @out_name: (out): Return location for return parameter or %NULL to ignore.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to egdbus_folder_call_get_display_name().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with egdbus_folder_call_get_display_name().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
egdbus_folder_call_get_display_name_finish (
    EGdbusFolder *proxy,
    gchar **out_name,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(s)",
                 out_name);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * egdbus_folder_call_get_display_name_sync:
 * @proxy: A #EGdbusFolderProxy.
 * @out_name: (out): Return location for return parameter or %NULL to ignore.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.getDisplayName">getDisplayName()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See egdbus_folder_call_get_display_name() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
egdbus_folder_call_get_display_name_sync (
    EGdbusFolder *proxy,
    gchar **out_name,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "getDisplayName",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(s)",
                 out_name);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * egdbus_folder_call_set_display_name:
 * @proxy: A #EGdbusFolderProxy.
 * @arg_name: Argument to pass with the method invocation.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.setDisplayName">setDisplayName()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call egdbus_folder_call_set_display_name_finish() to get the result of the operation.
 *
 * See egdbus_folder_call_set_display_name_sync() for the synchronous, blocking version of this method.
 */
void
egdbus_folder_call_set_display_name (
    EGdbusFolder *proxy,
    const gchar *arg_name,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "setDisplayName",
    g_variant_new ("(s)",
                   arg_name),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * egdbus_folder_call_set_display_name_finish:
 * @proxy: A #EGdbusFolderProxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to egdbus_folder_call_set_display_name().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with egdbus_folder_call_set_display_name().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
egdbus_folder_call_set_display_name_finish (
    EGdbusFolder *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * egdbus_folder_call_set_display_name_sync:
 * @proxy: A #EGdbusFolderProxy.
 * @arg_name: Argument to pass with the method invocation.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.setDisplayName">setDisplayName()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See egdbus_folder_call_set_display_name() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
egdbus_folder_call_set_display_name_sync (
    EGdbusFolder *proxy,
    const gchar *arg_name,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "setDisplayName",
    g_variant_new ("(s)",
                   arg_name),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * egdbus_folder_call_get_full_name:
 * @proxy: A #EGdbusFolderProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.getFullName">getFullName()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call egdbus_folder_call_get_full_name_finish() to get the result of the operation.
 *
 * See egdbus_folder_call_get_full_name_sync() for the synchronous, blocking version of this method.
 */
void
egdbus_folder_call_get_full_name (
    EGdbusFolder *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "getFullName",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * egdbus_folder_call_get_full_name_finish:
 * @proxy: A #EGdbusFolderProxy.
 * @out_name: (out): Return location for return parameter or %NULL to ignore.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to egdbus_folder_call_get_full_name().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with egdbus_folder_call_get_full_name().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
egdbus_folder_call_get_full_name_finish (
    EGdbusFolder *proxy,
    gchar **out_name,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(s)",
                 out_name);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * egdbus_folder_call_get_full_name_sync:
 * @proxy: A #EGdbusFolderProxy.
 * @out_name: (out): Return location for return parameter or %NULL to ignore.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.getFullName">getFullName()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See egdbus_folder_call_get_full_name() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
egdbus_folder_call_get_full_name_sync (
    EGdbusFolder *proxy,
    gchar **out_name,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "getFullName",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(s)",
                 out_name);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * egdbus_folder_call_set_full_name:
 * @proxy: A #EGdbusFolderProxy.
 * @arg_name: Argument to pass with the method invocation.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.setFullName">setFullName()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call egdbus_folder_call_set_full_name_finish() to get the result of the operation.
 *
 * See egdbus_folder_call_set_full_name_sync() for the synchronous, blocking version of this method.
 */
void
egdbus_folder_call_set_full_name (
    EGdbusFolder *proxy,
    const gchar *arg_name,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "setFullName",
    g_variant_new ("(s)",
                   arg_name),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * egdbus_folder_call_set_full_name_finish:
 * @proxy: A #EGdbusFolderProxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to egdbus_folder_call_set_full_name().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with egdbus_folder_call_set_full_name().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
egdbus_folder_call_set_full_name_finish (
    EGdbusFolder *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * egdbus_folder_call_set_full_name_sync:
 * @proxy: A #EGdbusFolderProxy.
 * @arg_name: Argument to pass with the method invocation.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.setFullName">setFullName()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See egdbus_folder_call_set_full_name() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
egdbus_folder_call_set_full_name_sync (
    EGdbusFolder *proxy,
    const gchar *arg_name,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "setFullName",
    g_variant_new ("(s)",
                   arg_name),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * egdbus_folder_call_get_description:
 * @proxy: A #EGdbusFolderProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.getDescription">getDescription()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call egdbus_folder_call_get_description_finish() to get the result of the operation.
 *
 * See egdbus_folder_call_get_description_sync() for the synchronous, blocking version of this method.
 */
void
egdbus_folder_call_get_description (
    EGdbusFolder *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "getDescription",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * egdbus_folder_call_get_description_finish:
 * @proxy: A #EGdbusFolderProxy.
 * @out_desc: (out): Return location for return parameter or %NULL to ignore.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to egdbus_folder_call_get_description().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with egdbus_folder_call_get_description().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
egdbus_folder_call_get_description_finish (
    EGdbusFolder *proxy,
    gchar **out_desc,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(s)",
                 out_desc);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * egdbus_folder_call_get_description_sync:
 * @proxy: A #EGdbusFolderProxy.
 * @out_desc: (out): Return location for return parameter or %NULL to ignore.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.getDescription">getDescription()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See egdbus_folder_call_get_description() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
egdbus_folder_call_get_description_sync (
    EGdbusFolder *proxy,
    gchar **out_desc,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "getDescription",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(s)",
                 out_desc);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * egdbus_folder_call_set_description:
 * @proxy: A #EGdbusFolderProxy.
 * @arg_desc: Argument to pass with the method invocation.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.setDescription">setDescription()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call egdbus_folder_call_set_description_finish() to get the result of the operation.
 *
 * See egdbus_folder_call_set_description_sync() for the synchronous, blocking version of this method.
 */
void
egdbus_folder_call_set_description (
    EGdbusFolder *proxy,
    const gchar *arg_desc,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "setDescription",
    g_variant_new ("(s)",
                   arg_desc),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * egdbus_folder_call_set_description_finish:
 * @proxy: A #EGdbusFolderProxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to egdbus_folder_call_set_description().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with egdbus_folder_call_set_description().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
egdbus_folder_call_set_description_finish (
    EGdbusFolder *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * egdbus_folder_call_set_description_sync:
 * @proxy: A #EGdbusFolderProxy.
 * @arg_desc: Argument to pass with the method invocation.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.setDescription">setDescription()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See egdbus_folder_call_set_description() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
egdbus_folder_call_set_description_sync (
    EGdbusFolder *proxy,
    const gchar *arg_desc,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "setDescription",
    g_variant_new ("(s)",
                   arg_desc),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * egdbus_folder_call_get_permanent_flags:
 * @proxy: A #EGdbusFolderProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.getPermanentFlags">getPermanentFlags()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call egdbus_folder_call_get_permanent_flags_finish() to get the result of the operation.
 *
 * See egdbus_folder_call_get_permanent_flags_sync() for the synchronous, blocking version of this method.
 */
void
egdbus_folder_call_get_permanent_flags (
    EGdbusFolder *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "getPermanentFlags",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * egdbus_folder_call_get_permanent_flags_finish:
 * @proxy: A #EGdbusFolderProxy.
 * @out_flags: (out): Return location for return parameter or %NULL to ignore.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to egdbus_folder_call_get_permanent_flags().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with egdbus_folder_call_get_permanent_flags().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
egdbus_folder_call_get_permanent_flags_finish (
    EGdbusFolder *proxy,
    guint *out_flags,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(u)",
                 out_flags);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * egdbus_folder_call_get_permanent_flags_sync:
 * @proxy: A #EGdbusFolderProxy.
 * @out_flags: (out): Return location for return parameter or %NULL to ignore.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.getPermanentFlags">getPermanentFlags()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See egdbus_folder_call_get_permanent_flags() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
egdbus_folder_call_get_permanent_flags_sync (
    EGdbusFolder *proxy,
    guint *out_flags,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "getPermanentFlags",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(u)",
                 out_flags);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * egdbus_folder_call_has_summary_capability:
 * @proxy: A #EGdbusFolderProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.hasSummaryCapability">hasSummaryCapability()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call egdbus_folder_call_has_summary_capability_finish() to get the result of the operation.
 *
 * See egdbus_folder_call_has_summary_capability_sync() for the synchronous, blocking version of this method.
 */
void
egdbus_folder_call_has_summary_capability (
    EGdbusFolder *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "hasSummaryCapability",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * egdbus_folder_call_has_summary_capability_finish:
 * @proxy: A #EGdbusFolderProxy.
 * @out_summary: (out): Return location for return parameter or %NULL to ignore.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to egdbus_folder_call_has_summary_capability().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with egdbus_folder_call_has_summary_capability().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
egdbus_folder_call_has_summary_capability_finish (
    EGdbusFolder *proxy,
    gboolean *out_summary,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(b)",
                 out_summary);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * egdbus_folder_call_has_summary_capability_sync:
 * @proxy: A #EGdbusFolderProxy.
 * @out_summary: (out): Return location for return parameter or %NULL to ignore.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.hasSummaryCapability">hasSummaryCapability()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See egdbus_folder_call_has_summary_capability() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
egdbus_folder_call_has_summary_capability_sync (
    EGdbusFolder *proxy,
    gboolean *out_summary,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "hasSummaryCapability",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(b)",
                 out_summary);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * egdbus_folder_call_has_search_capability:
 * @proxy: A #EGdbusFolderProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.hasSearchCapability">hasSearchCapability()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call egdbus_folder_call_has_search_capability_finish() to get the result of the operation.
 *
 * See egdbus_folder_call_has_search_capability_sync() for the synchronous, blocking version of this method.
 */
void
egdbus_folder_call_has_search_capability (
    EGdbusFolder *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "hasSearchCapability",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * egdbus_folder_call_has_search_capability_finish:
 * @proxy: A #EGdbusFolderProxy.
 * @out_search: (out): Return location for return parameter or %NULL to ignore.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to egdbus_folder_call_has_search_capability().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with egdbus_folder_call_has_search_capability().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
egdbus_folder_call_has_search_capability_finish (
    EGdbusFolder *proxy,
    gboolean *out_search,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(b)",
                 out_search);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * egdbus_folder_call_has_search_capability_sync:
 * @proxy: A #EGdbusFolderProxy.
 * @out_search: (out): Return location for return parameter or %NULL to ignore.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.hasSearchCapability">hasSearchCapability()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See egdbus_folder_call_has_search_capability() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
egdbus_folder_call_has_search_capability_sync (
    EGdbusFolder *proxy,
    gboolean *out_search,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "hasSearchCapability",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(b)",
                 out_search);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * egdbus_folder_call_total_message_count:
 * @proxy: A #EGdbusFolderProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.totalMessageCount">totalMessageCount()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call egdbus_folder_call_total_message_count_finish() to get the result of the operation.
 *
 * See egdbus_folder_call_total_message_count_sync() for the synchronous, blocking version of this method.
 */
void
egdbus_folder_call_total_message_count (
    EGdbusFolder *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "totalMessageCount",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * egdbus_folder_call_total_message_count_finish:
 * @proxy: A #EGdbusFolderProxy.
 * @out_count: (out): Return location for return parameter or %NULL to ignore.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to egdbus_folder_call_total_message_count().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with egdbus_folder_call_total_message_count().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
egdbus_folder_call_total_message_count_finish (
    EGdbusFolder *proxy,
    gint *out_count,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(i)",
                 out_count);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * egdbus_folder_call_total_message_count_sync:
 * @proxy: A #EGdbusFolderProxy.
 * @out_count: (out): Return location for return parameter or %NULL to ignore.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.totalMessageCount">totalMessageCount()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See egdbus_folder_call_total_message_count() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
egdbus_folder_call_total_message_count_sync (
    EGdbusFolder *proxy,
    gint *out_count,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "totalMessageCount",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(i)",
                 out_count);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * egdbus_folder_call_unread_message_count:
 * @proxy: A #EGdbusFolderProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.unreadMessageCount">unreadMessageCount()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call egdbus_folder_call_unread_message_count_finish() to get the result of the operation.
 *
 * See egdbus_folder_call_unread_message_count_sync() for the synchronous, blocking version of this method.
 */
void
egdbus_folder_call_unread_message_count (
    EGdbusFolder *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "unreadMessageCount",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * egdbus_folder_call_unread_message_count_finish:
 * @proxy: A #EGdbusFolderProxy.
 * @out_count: (out): Return location for return parameter or %NULL to ignore.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to egdbus_folder_call_unread_message_count().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with egdbus_folder_call_unread_message_count().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
egdbus_folder_call_unread_message_count_finish (
    EGdbusFolder *proxy,
    gint *out_count,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(i)",
                 out_count);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * egdbus_folder_call_unread_message_count_sync:
 * @proxy: A #EGdbusFolderProxy.
 * @out_count: (out): Return location for return parameter or %NULL to ignore.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.unreadMessageCount">unreadMessageCount()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See egdbus_folder_call_unread_message_count() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
egdbus_folder_call_unread_message_count_sync (
    EGdbusFolder *proxy,
    gint *out_count,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "unreadMessageCount",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(i)",
                 out_count);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * egdbus_folder_call_deleted_message_count:
 * @proxy: A #EGdbusFolderProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.deletedMessageCount">deletedMessageCount()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call egdbus_folder_call_deleted_message_count_finish() to get the result of the operation.
 *
 * See egdbus_folder_call_deleted_message_count_sync() for the synchronous, blocking version of this method.
 */
void
egdbus_folder_call_deleted_message_count (
    EGdbusFolder *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "deletedMessageCount",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * egdbus_folder_call_deleted_message_count_finish:
 * @proxy: A #EGdbusFolderProxy.
 * @out_count: (out): Return location for return parameter or %NULL to ignore.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to egdbus_folder_call_deleted_message_count().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with egdbus_folder_call_deleted_message_count().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
egdbus_folder_call_deleted_message_count_finish (
    EGdbusFolder *proxy,
    gint *out_count,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(i)",
                 out_count);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * egdbus_folder_call_deleted_message_count_sync:
 * @proxy: A #EGdbusFolderProxy.
 * @out_count: (out): Return location for return parameter or %NULL to ignore.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.deletedMessageCount">deletedMessageCount()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See egdbus_folder_call_deleted_message_count() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
egdbus_folder_call_deleted_message_count_sync (
    EGdbusFolder *proxy,
    gint *out_count,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "deletedMessageCount",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(i)",
                 out_count);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * egdbus_folder_call_get_message_flags:
 * @proxy: A #EGdbusFolderProxy.
 * @arg_uid: Argument to pass with the method invocation.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.getMessageFlags">getMessageFlags()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call egdbus_folder_call_get_message_flags_finish() to get the result of the operation.
 *
 * See egdbus_folder_call_get_message_flags_sync() for the synchronous, blocking version of this method.
 */
void
egdbus_folder_call_get_message_flags (
    EGdbusFolder *proxy,
    const gchar *arg_uid,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "getMessageFlags",
    g_variant_new ("(s)",
                   arg_uid),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * egdbus_folder_call_get_message_flags_finish:
 * @proxy: A #EGdbusFolderProxy.
 * @out_flags: (out): Return location for return parameter or %NULL to ignore.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to egdbus_folder_call_get_message_flags().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with egdbus_folder_call_get_message_flags().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
egdbus_folder_call_get_message_flags_finish (
    EGdbusFolder *proxy,
    guint *out_flags,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(u)",
                 out_flags);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * egdbus_folder_call_get_message_flags_sync:
 * @proxy: A #EGdbusFolderProxy.
 * @arg_uid: Argument to pass with the method invocation.
 * @out_flags: (out): Return location for return parameter or %NULL to ignore.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.getMessageFlags">getMessageFlags()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See egdbus_folder_call_get_message_flags() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
egdbus_folder_call_get_message_flags_sync (
    EGdbusFolder *proxy,
    const gchar *arg_uid,
    guint *out_flags,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "getMessageFlags",
    g_variant_new ("(s)",
                   arg_uid),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(u)",
                 out_flags);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * egdbus_folder_call_set_message_flags:
 * @proxy: A #EGdbusFolderProxy.
 * @arg_uid: Argument to pass with the method invocation.
 * @arg_flags: Argument to pass with the method invocation.
 * @arg_set: Argument to pass with the method invocation.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.setMessageFlags">setMessageFlags()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call egdbus_folder_call_set_message_flags_finish() to get the result of the operation.
 *
 * See egdbus_folder_call_set_message_flags_sync() for the synchronous, blocking version of this method.
 */
void
egdbus_folder_call_set_message_flags (
    EGdbusFolder *proxy,
    const gchar *arg_uid,
    guint arg_flags,
    guint arg_set,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "setMessageFlags",
    g_variant_new ("(suu)",
                   arg_uid,
                   arg_flags,
                   arg_set),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * egdbus_folder_call_set_message_flags_finish:
 * @proxy: A #EGdbusFolderProxy.
 * @out_success: (out): Return location for return parameter or %NULL to ignore.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to egdbus_folder_call_set_message_flags().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with egdbus_folder_call_set_message_flags().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
egdbus_folder_call_set_message_flags_finish (
    EGdbusFolder *proxy,
    gboolean *out_success,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(b)",
                 out_success);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * egdbus_folder_call_set_message_flags_sync:
 * @proxy: A #EGdbusFolderProxy.
 * @arg_uid: Argument to pass with the method invocation.
 * @arg_flags: Argument to pass with the method invocation.
 * @arg_set: Argument to pass with the method invocation.
 * @out_success: (out): Return location for return parameter or %NULL to ignore.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.setMessageFlags">setMessageFlags()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See egdbus_folder_call_set_message_flags() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
egdbus_folder_call_set_message_flags_sync (
    EGdbusFolder *proxy,
    const gchar *arg_uid,
    guint arg_flags,
    guint arg_set,
    gboolean *out_success,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "setMessageFlags",
    g_variant_new ("(suu)",
                   arg_uid,
                   arg_flags,
                   arg_set),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(b)",
                 out_success);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * egdbus_folder_call_get_message_user_flag:
 * @proxy: A #EGdbusFolderProxy.
 * @arg_uid: Argument to pass with the method invocation.
 * @arg_flagname: Argument to pass with the method invocation.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.getMessageUserFlag">getMessageUserFlag()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call egdbus_folder_call_get_message_user_flag_finish() to get the result of the operation.
 *
 * See egdbus_folder_call_get_message_user_flag_sync() for the synchronous, blocking version of this method.
 */
void
egdbus_folder_call_get_message_user_flag (
    EGdbusFolder *proxy,
    const gchar *arg_uid,
    const gchar *arg_flagname,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "getMessageUserFlag",
    g_variant_new ("(ss)",
                   arg_uid,
                   arg_flagname),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * egdbus_folder_call_get_message_user_flag_finish:
 * @proxy: A #EGdbusFolderProxy.
 * @out_flag: (out): Return location for return parameter or %NULL to ignore.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to egdbus_folder_call_get_message_user_flag().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with egdbus_folder_call_get_message_user_flag().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
egdbus_folder_call_get_message_user_flag_finish (
    EGdbusFolder *proxy,
    gboolean *out_flag,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(b)",
                 out_flag);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * egdbus_folder_call_get_message_user_flag_sync:
 * @proxy: A #EGdbusFolderProxy.
 * @arg_uid: Argument to pass with the method invocation.
 * @arg_flagname: Argument to pass with the method invocation.
 * @out_flag: (out): Return location for return parameter or %NULL to ignore.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.getMessageUserFlag">getMessageUserFlag()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See egdbus_folder_call_get_message_user_flag() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
egdbus_folder_call_get_message_user_flag_sync (
    EGdbusFolder *proxy,
    const gchar *arg_uid,
    const gchar *arg_flagname,
    gboolean *out_flag,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "getMessageUserFlag",
    g_variant_new ("(ss)",
                   arg_uid,
                   arg_flagname),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(b)",
                 out_flag);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * egdbus_folder_call_set_message_user_flag:
 * @proxy: A #EGdbusFolderProxy.
 * @arg_uid: Argument to pass with the method invocation.
 * @arg_flagname: Argument to pass with the method invocation.
 * @arg_set: Argument to pass with the method invocation.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.setMessageUserFlag">setMessageUserFlag()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call egdbus_folder_call_set_message_user_flag_finish() to get the result of the operation.
 *
 * See egdbus_folder_call_set_message_user_flag_sync() for the synchronous, blocking version of this method.
 */
void
egdbus_folder_call_set_message_user_flag (
    EGdbusFolder *proxy,
    const gchar *arg_uid,
    const gchar *arg_flagname,
    guint arg_set,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "setMessageUserFlag",
    g_variant_new ("(ssu)",
                   arg_uid,
                   arg_flagname,
                   arg_set),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * egdbus_folder_call_set_message_user_flag_finish:
 * @proxy: A #EGdbusFolderProxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to egdbus_folder_call_set_message_user_flag().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with egdbus_folder_call_set_message_user_flag().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
egdbus_folder_call_set_message_user_flag_finish (
    EGdbusFolder *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * egdbus_folder_call_set_message_user_flag_sync:
 * @proxy: A #EGdbusFolderProxy.
 * @arg_uid: Argument to pass with the method invocation.
 * @arg_flagname: Argument to pass with the method invocation.
 * @arg_set: Argument to pass with the method invocation.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.setMessageUserFlag">setMessageUserFlag()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See egdbus_folder_call_set_message_user_flag() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
egdbus_folder_call_set_message_user_flag_sync (
    EGdbusFolder *proxy,
    const gchar *arg_uid,
    const gchar *arg_flagname,
    guint arg_set,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "setMessageUserFlag",
    g_variant_new ("(ssu)",
                   arg_uid,
                   arg_flagname,
                   arg_set),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * egdbus_folder_call_get_message_user_tag:
 * @proxy: A #EGdbusFolderProxy.
 * @arg_uid: Argument to pass with the method invocation.
 * @arg_param: Argument to pass with the method invocation.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.getMessageUserTag">getMessageUserTag()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call egdbus_folder_call_get_message_user_tag_finish() to get the result of the operation.
 *
 * See egdbus_folder_call_get_message_user_tag_sync() for the synchronous, blocking version of this method.
 */
void
egdbus_folder_call_get_message_user_tag (
    EGdbusFolder *proxy,
    const gchar *arg_uid,
    const gchar *arg_param,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "getMessageUserTag",
    g_variant_new ("(ss)",
                   arg_uid,
                   arg_param),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * egdbus_folder_call_get_message_user_tag_finish:
 * @proxy: A #EGdbusFolderProxy.
 * @out_value: (out): Return location for return parameter or %NULL to ignore.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to egdbus_folder_call_get_message_user_tag().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with egdbus_folder_call_get_message_user_tag().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
egdbus_folder_call_get_message_user_tag_finish (
    EGdbusFolder *proxy,
    gchar **out_value,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(s)",
                 out_value);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * egdbus_folder_call_get_message_user_tag_sync:
 * @proxy: A #EGdbusFolderProxy.
 * @arg_uid: Argument to pass with the method invocation.
 * @arg_param: Argument to pass with the method invocation.
 * @out_value: (out): Return location for return parameter or %NULL to ignore.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.getMessageUserTag">getMessageUserTag()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See egdbus_folder_call_get_message_user_tag() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
egdbus_folder_call_get_message_user_tag_sync (
    EGdbusFolder *proxy,
    const gchar *arg_uid,
    const gchar *arg_param,
    gchar **out_value,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "getMessageUserTag",
    g_variant_new ("(ss)",
                   arg_uid,
                   arg_param),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(s)",
                 out_value);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * egdbus_folder_call_set_message_user_tag:
 * @proxy: A #EGdbusFolderProxy.
 * @arg_uid: Argument to pass with the method invocation.
 * @arg_param: Argument to pass with the method invocation.
 * @arg_value: Argument to pass with the method invocation.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.setMessageUserTag">setMessageUserTag()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call egdbus_folder_call_set_message_user_tag_finish() to get the result of the operation.
 *
 * See egdbus_folder_call_set_message_user_tag_sync() for the synchronous, blocking version of this method.
 */
void
egdbus_folder_call_set_message_user_tag (
    EGdbusFolder *proxy,
    const gchar *arg_uid,
    const gchar *arg_param,
    const gchar *arg_value,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "setMessageUserTag",
    g_variant_new ("(sss)",
                   arg_uid,
                   arg_param,
                   arg_value),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * egdbus_folder_call_set_message_user_tag_finish:
 * @proxy: A #EGdbusFolderProxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to egdbus_folder_call_set_message_user_tag().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with egdbus_folder_call_set_message_user_tag().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
egdbus_folder_call_set_message_user_tag_finish (
    EGdbusFolder *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * egdbus_folder_call_set_message_user_tag_sync:
 * @proxy: A #EGdbusFolderProxy.
 * @arg_uid: Argument to pass with the method invocation.
 * @arg_param: Argument to pass with the method invocation.
 * @arg_value: Argument to pass with the method invocation.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.setMessageUserTag">setMessageUserTag()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See egdbus_folder_call_set_message_user_tag() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
egdbus_folder_call_set_message_user_tag_sync (
    EGdbusFolder *proxy,
    const gchar *arg_uid,
    const gchar *arg_param,
    const gchar *arg_value,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "setMessageUserTag",
    g_variant_new ("(sss)",
                   arg_uid,
                   arg_param,
                   arg_value),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * egdbus_folder_call_get_parent_store:
 * @proxy: A #EGdbusFolderProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.getParentStore">getParentStore()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call egdbus_folder_call_get_parent_store_finish() to get the result of the operation.
 *
 * See egdbus_folder_call_get_parent_store_sync() for the synchronous, blocking version of this method.
 */
void
egdbus_folder_call_get_parent_store (
    EGdbusFolder *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "getParentStore",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * egdbus_folder_call_get_parent_store_finish:
 * @proxy: A #EGdbusFolderProxy.
 * @out_store: (out): Return location for return parameter or %NULL to ignore.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to egdbus_folder_call_get_parent_store().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with egdbus_folder_call_get_parent_store().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
egdbus_folder_call_get_parent_store_finish (
    EGdbusFolder *proxy,
    gchar **out_store,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(o)",
                 out_store);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * egdbus_folder_call_get_parent_store_sync:
 * @proxy: A #EGdbusFolderProxy.
 * @out_store: (out): Return location for return parameter or %NULL to ignore.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.getParentStore">getParentStore()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See egdbus_folder_call_get_parent_store() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
egdbus_folder_call_get_parent_store_sync (
    EGdbusFolder *proxy,
    gchar **out_store,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "getParentStore",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(o)",
                 out_store);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * egdbus_folder_call_append_message:
 * @proxy: A #EGdbusFolderProxy.
 * @arg_info: Argument to pass with the method invocation.
 * @arg_message: Argument to pass with the method invocation.
 * @arg_ops: Argument to pass with the method invocation.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.AppendMessage">AppendMessage()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call egdbus_folder_call_append_message_finish() to get the result of the operation.
 *
 * See egdbus_folder_call_append_message_sync() for the synchronous, blocking version of this method.
 */
void
egdbus_folder_call_append_message (
    EGdbusFolder *proxy,
    GVariant *arg_info,
    const gchar *arg_message,
    const gchar *arg_ops,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "AppendMessage",
    g_variant_new ("(@(sssssssuutttiatasa(ss))so)",
                   arg_info,
                   arg_message,
                   arg_ops),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * egdbus_folder_call_append_message_finish:
 * @proxy: A #EGdbusFolderProxy.
 * @out_appendeduid: (out): Return location for return parameter or %NULL to ignore.
 * @out_success: (out): Return location for return parameter or %NULL to ignore.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to egdbus_folder_call_append_message().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with egdbus_folder_call_append_message().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
egdbus_folder_call_append_message_finish (
    EGdbusFolder *proxy,
    gchar **out_appendeduid,
    gboolean *out_success,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(sb)",
                 out_appendeduid,
                 out_success);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * egdbus_folder_call_append_message_sync:
 * @proxy: A #EGdbusFolderProxy.
 * @arg_info: Argument to pass with the method invocation.
 * @arg_message: Argument to pass with the method invocation.
 * @arg_ops: Argument to pass with the method invocation.
 * @out_appendeduid: (out): Return location for return parameter or %NULL to ignore.
 * @out_success: (out): Return location for return parameter or %NULL to ignore.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.AppendMessage">AppendMessage()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See egdbus_folder_call_append_message() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
egdbus_folder_call_append_message_sync (
    EGdbusFolder *proxy,
    GVariant *arg_info,
    const gchar *arg_message,
    const gchar *arg_ops,
    gchar **out_appendeduid,
    gboolean *out_success,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "AppendMessage",
    g_variant_new ("(@(sssssssuutttiatasa(ss))so)",
                   arg_info,
                   arg_message,
                   arg_ops),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(sb)",
                 out_appendeduid,
                 out_success);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * egdbus_folder_call_get_uids:
 * @proxy: A #EGdbusFolderProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.getUids">getUids()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call egdbus_folder_call_get_uids_finish() to get the result of the operation.
 *
 * See egdbus_folder_call_get_uids_sync() for the synchronous, blocking version of this method.
 */
void
egdbus_folder_call_get_uids (
    EGdbusFolder *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "getUids",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * egdbus_folder_call_get_uids_finish:
 * @proxy: A #EGdbusFolderProxy.
 * @out_uids: (out): Return location for return parameter or %NULL to ignore.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to egdbus_folder_call_get_uids().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with egdbus_folder_call_get_uids().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
egdbus_folder_call_get_uids_finish (
    EGdbusFolder *proxy,
    gchar ***out_uids,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(^as)",
                 out_uids);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * egdbus_folder_call_get_uids_sync:
 * @proxy: A #EGdbusFolderProxy.
 * @out_uids: (out): Return location for return parameter or %NULL to ignore.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.getUids">getUids()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See egdbus_folder_call_get_uids() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
egdbus_folder_call_get_uids_sync (
    EGdbusFolder *proxy,
    gchar ***out_uids,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "getUids",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(^as)",
                 out_uids);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * egdbus_folder_call_get_message:
 * @proxy: A #EGdbusFolderProxy.
 * @arg_uid: Argument to pass with the method invocation.
 * @arg_ops: Argument to pass with the method invocation.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.getMessage">getMessage()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call egdbus_folder_call_get_message_finish() to get the result of the operation.
 *
 * See egdbus_folder_call_get_message_sync() for the synchronous, blocking version of this method.
 */
void
egdbus_folder_call_get_message (
    EGdbusFolder *proxy,
    const gchar *arg_uid,
    const gchar *arg_ops,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "getMessage",
    g_variant_new ("(so)",
                   arg_uid,
                   arg_ops),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * egdbus_folder_call_get_message_finish:
 * @proxy: A #EGdbusFolderProxy.
 * @out_message: (out): Return location for return parameter or %NULL to ignore.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to egdbus_folder_call_get_message().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with egdbus_folder_call_get_message().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
egdbus_folder_call_get_message_finish (
    EGdbusFolder *proxy,
    gchar **out_message,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(s)",
                 out_message);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * egdbus_folder_call_get_message_sync:
 * @proxy: A #EGdbusFolderProxy.
 * @arg_uid: Argument to pass with the method invocation.
 * @arg_ops: Argument to pass with the method invocation.
 * @out_message: (out): Return location for return parameter or %NULL to ignore.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.getMessage">getMessage()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See egdbus_folder_call_get_message() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
egdbus_folder_call_get_message_sync (
    EGdbusFolder *proxy,
    const gchar *arg_uid,
    const gchar *arg_ops,
    gchar **out_message,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "getMessage",
    g_variant_new ("(so)",
                   arg_uid,
                   arg_ops),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(s)",
                 out_message);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * egdbus_folder_call_get_quota_info:
 * @proxy: A #EGdbusFolderProxy.
 * @arg_ops: Argument to pass with the method invocation.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.getQuotaInfo">getQuotaInfo()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call egdbus_folder_call_get_quota_info_finish() to get the result of the operation.
 *
 * See egdbus_folder_call_get_quota_info_sync() for the synchronous, blocking version of this method.
 */
void
egdbus_folder_call_get_quota_info (
    EGdbusFolder *proxy,
    const gchar *arg_ops,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "getQuotaInfo",
    g_variant_new ("(o)",
                   arg_ops),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * egdbus_folder_call_get_quota_info_finish:
 * @proxy: A #EGdbusFolderProxy.
 * @out_quotainfo: (out): Return location for return parameter or %NULL to ignore.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to egdbus_folder_call_get_quota_info().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with egdbus_folder_call_get_quota_info().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
egdbus_folder_call_get_quota_info_finish (
    EGdbusFolder *proxy,
    GVariant **out_quotainfo,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(@a(stt))",
                 out_quotainfo);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * egdbus_folder_call_get_quota_info_sync:
 * @proxy: A #EGdbusFolderProxy.
 * @arg_ops: Argument to pass with the method invocation.
 * @out_quotainfo: (out): Return location for return parameter or %NULL to ignore.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.getQuotaInfo">getQuotaInfo()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See egdbus_folder_call_get_quota_info() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
egdbus_folder_call_get_quota_info_sync (
    EGdbusFolder *proxy,
    const gchar *arg_ops,
    GVariant **out_quotainfo,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "getQuotaInfo",
    g_variant_new ("(o)",
                   arg_ops),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(@a(stt))",
                 out_quotainfo);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * egdbus_folder_call_search_by_expression:
 * @proxy: A #EGdbusFolderProxy.
 * @arg_expression: Argument to pass with the method invocation.
 * @arg_ops: Argument to pass with the method invocation.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.searchByExpression">searchByExpression()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call egdbus_folder_call_search_by_expression_finish() to get the result of the operation.
 *
 * See egdbus_folder_call_search_by_expression_sync() for the synchronous, blocking version of this method.
 */
void
egdbus_folder_call_search_by_expression (
    EGdbusFolder *proxy,
    const gchar *arg_expression,
    const gchar *arg_ops,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "searchByExpression",
    g_variant_new ("(so)",
                   arg_expression,
                   arg_ops),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * egdbus_folder_call_search_by_expression_finish:
 * @proxy: A #EGdbusFolderProxy.
 * @out_uids: (out): Return location for return parameter or %NULL to ignore.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to egdbus_folder_call_search_by_expression().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with egdbus_folder_call_search_by_expression().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
egdbus_folder_call_search_by_expression_finish (
    EGdbusFolder *proxy,
    gchar ***out_uids,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(^as)",
                 out_uids);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * egdbus_folder_call_search_by_expression_sync:
 * @proxy: A #EGdbusFolderProxy.
 * @arg_expression: Argument to pass with the method invocation.
 * @arg_ops: Argument to pass with the method invocation.
 * @out_uids: (out): Return location for return parameter or %NULL to ignore.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.searchByExpression">searchByExpression()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See egdbus_folder_call_search_by_expression() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
egdbus_folder_call_search_by_expression_sync (
    EGdbusFolder *proxy,
    const gchar *arg_expression,
    const gchar *arg_ops,
    gchar ***out_uids,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "searchByExpression",
    g_variant_new ("(so)",
                   arg_expression,
                   arg_ops),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(^as)",
                 out_uids);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * egdbus_folder_call_search_sort_by_expression:
 * @proxy: A #EGdbusFolderProxy.
 * @arg_expression: Argument to pass with the method invocation.
 * @arg_sort: Argument to pass with the method invocation.
 * @arg_ascending: Argument to pass with the method invocation.
 * @arg_ops: Argument to pass with the method invocation.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.searchSortByExpression">searchSortByExpression()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call egdbus_folder_call_search_sort_by_expression_finish() to get the result of the operation.
 *
 * See egdbus_folder_call_search_sort_by_expression_sync() for the synchronous, blocking version of this method.
 */
void
egdbus_folder_call_search_sort_by_expression (
    EGdbusFolder *proxy,
    const gchar *arg_expression,
    const gchar *arg_sort,
    gboolean arg_ascending,
    const gchar *arg_ops,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "searchSortByExpression",
    g_variant_new ("(ssbo)",
                   arg_expression,
                   arg_sort,
                   arg_ascending,
                   arg_ops),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * egdbus_folder_call_search_sort_by_expression_finish:
 * @proxy: A #EGdbusFolderProxy.
 * @out_uids: (out): Return location for return parameter or %NULL to ignore.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to egdbus_folder_call_search_sort_by_expression().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with egdbus_folder_call_search_sort_by_expression().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
egdbus_folder_call_search_sort_by_expression_finish (
    EGdbusFolder *proxy,
    gchar ***out_uids,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(^as)",
                 out_uids);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * egdbus_folder_call_search_sort_by_expression_sync:
 * @proxy: A #EGdbusFolderProxy.
 * @arg_expression: Argument to pass with the method invocation.
 * @arg_sort: Argument to pass with the method invocation.
 * @arg_ascending: Argument to pass with the method invocation.
 * @arg_ops: Argument to pass with the method invocation.
 * @out_uids: (out): Return location for return parameter or %NULL to ignore.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.searchSortByExpression">searchSortByExpression()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See egdbus_folder_call_search_sort_by_expression() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
egdbus_folder_call_search_sort_by_expression_sync (
    EGdbusFolder *proxy,
    const gchar *arg_expression,
    const gchar *arg_sort,
    gboolean arg_ascending,
    const gchar *arg_ops,
    gchar ***out_uids,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "searchSortByExpression",
    g_variant_new ("(ssbo)",
                   arg_expression,
                   arg_sort,
                   arg_ascending,
                   arg_ops),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(^as)",
                 out_uids);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * egdbus_folder_call_search_by_uids:
 * @proxy: A #EGdbusFolderProxy.
 * @arg_expression: Argument to pass with the method invocation.
 * @arg_searchuids: Argument to pass with the method invocation.
 * @arg_ops: Argument to pass with the method invocation.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.searchByUids">searchByUids()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call egdbus_folder_call_search_by_uids_finish() to get the result of the operation.
 *
 * See egdbus_folder_call_search_by_uids_sync() for the synchronous, blocking version of this method.
 */
void
egdbus_folder_call_search_by_uids (
    EGdbusFolder *proxy,
    const gchar *arg_expression,
    const gchar *const *arg_searchuids,
    const gchar *arg_ops,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "searchByUids",
    g_variant_new ("(s^aso)",
                   arg_expression,
                   arg_searchuids,
                   arg_ops),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * egdbus_folder_call_search_by_uids_finish:
 * @proxy: A #EGdbusFolderProxy.
 * @out_resultuids: (out): Return location for return parameter or %NULL to ignore.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to egdbus_folder_call_search_by_uids().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with egdbus_folder_call_search_by_uids().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
egdbus_folder_call_search_by_uids_finish (
    EGdbusFolder *proxy,
    gchar ***out_resultuids,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(^as)",
                 out_resultuids);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * egdbus_folder_call_search_by_uids_sync:
 * @proxy: A #EGdbusFolderProxy.
 * @arg_expression: Argument to pass with the method invocation.
 * @arg_searchuids: Argument to pass with the method invocation.
 * @arg_ops: Argument to pass with the method invocation.
 * @out_resultuids: (out): Return location for return parameter or %NULL to ignore.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.searchByUids">searchByUids()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See egdbus_folder_call_search_by_uids() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
egdbus_folder_call_search_by_uids_sync (
    EGdbusFolder *proxy,
    const gchar *arg_expression,
    const gchar *const *arg_searchuids,
    const gchar *arg_ops,
    gchar ***out_resultuids,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "searchByUids",
    g_variant_new ("(s^aso)",
                   arg_expression,
                   arg_searchuids,
                   arg_ops),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(^as)",
                 out_resultuids);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * egdbus_folder_call_get_message_info:
 * @proxy: A #EGdbusFolderProxy.
 * @arg_uid: Argument to pass with the method invocation.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.getMessageInfo">getMessageInfo()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call egdbus_folder_call_get_message_info_finish() to get the result of the operation.
 *
 * See egdbus_folder_call_get_message_info_sync() for the synchronous, blocking version of this method.
 */
void
egdbus_folder_call_get_message_info (
    EGdbusFolder *proxy,
    const gchar *arg_uid,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "getMessageInfo",
    g_variant_new ("(s)",
                   arg_uid),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * egdbus_folder_call_get_message_info_finish:
 * @proxy: A #EGdbusFolderProxy.
 * @out_info: (out): Return location for return parameter or %NULL to ignore.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to egdbus_folder_call_get_message_info().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with egdbus_folder_call_get_message_info().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
egdbus_folder_call_get_message_info_finish (
    EGdbusFolder *proxy,
    GVariant **out_info,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(@(sssssssuutttiatasa(ss)))",
                 out_info);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * egdbus_folder_call_get_message_info_sync:
 * @proxy: A #EGdbusFolderProxy.
 * @arg_uid: Argument to pass with the method invocation.
 * @out_info: (out): Return location for return parameter or %NULL to ignore.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.getMessageInfo">getMessageInfo()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See egdbus_folder_call_get_message_info() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
egdbus_folder_call_get_message_info_sync (
    EGdbusFolder *proxy,
    const gchar *arg_uid,
    GVariant **out_info,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "getMessageInfo",
    g_variant_new ("(s)",
                   arg_uid),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(@(sssssssuutttiatasa(ss)))",
                 out_info);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * egdbus_folder_call_transfer_messages_to:
 * @proxy: A #EGdbusFolderProxy.
 * @arg_uids: Argument to pass with the method invocation.
 * @arg_destfolder: Argument to pass with the method invocation.
 * @arg_deleteoriginals: Argument to pass with the method invocation.
 * @arg_ops: Argument to pass with the method invocation.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.transferMessagesTo">transferMessagesTo()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call egdbus_folder_call_transfer_messages_to_finish() to get the result of the operation.
 *
 * See egdbus_folder_call_transfer_messages_to_sync() for the synchronous, blocking version of this method.
 */
void
egdbus_folder_call_transfer_messages_to (
    EGdbusFolder *proxy,
    const gchar *const *arg_uids,
    const gchar *arg_destfolder,
    gboolean arg_deleteoriginals,
    const gchar *arg_ops,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "transferMessagesTo",
    g_variant_new ("(^asobo)",
                   arg_uids,
                   arg_destfolder,
                   arg_deleteoriginals,
                   arg_ops),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * egdbus_folder_call_transfer_messages_to_finish:
 * @proxy: A #EGdbusFolderProxy.
 * @out_returnuids: (out): Return location for return parameter or %NULL to ignore.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to egdbus_folder_call_transfer_messages_to().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with egdbus_folder_call_transfer_messages_to().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
egdbus_folder_call_transfer_messages_to_finish (
    EGdbusFolder *proxy,
    gchar ***out_returnuids,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(^as)",
                 out_returnuids);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * egdbus_folder_call_transfer_messages_to_sync:
 * @proxy: A #EGdbusFolderProxy.
 * @arg_uids: Argument to pass with the method invocation.
 * @arg_destfolder: Argument to pass with the method invocation.
 * @arg_deleteoriginals: Argument to pass with the method invocation.
 * @arg_ops: Argument to pass with the method invocation.
 * @out_returnuids: (out): Return location for return parameter or %NULL to ignore.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.transferMessagesTo">transferMessagesTo()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See egdbus_folder_call_transfer_messages_to() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
egdbus_folder_call_transfer_messages_to_sync (
    EGdbusFolder *proxy,
    const gchar *const *arg_uids,
    const gchar *arg_destfolder,
    gboolean arg_deleteoriginals,
    const gchar *arg_ops,
    gchar ***out_returnuids,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "transferMessagesTo",
    g_variant_new ("(^asobo)",
                   arg_uids,
                   arg_destfolder,
                   arg_deleteoriginals,
                   arg_ops),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(^as)",
                 out_returnuids);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * egdbus_folder_call_prepare_summary:
 * @proxy: A #EGdbusFolderProxy.
 * @arg_ops: Argument to pass with the method invocation.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.prepareSummary">prepareSummary()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call egdbus_folder_call_prepare_summary_finish() to get the result of the operation.
 *
 * See egdbus_folder_call_prepare_summary_sync() for the synchronous, blocking version of this method.
 */
void
egdbus_folder_call_prepare_summary (
    EGdbusFolder *proxy,
    const gchar *arg_ops,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "prepareSummary",
    g_variant_new ("(o)",
                   arg_ops),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * egdbus_folder_call_prepare_summary_finish:
 * @proxy: A #EGdbusFolderProxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to egdbus_folder_call_prepare_summary().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with egdbus_folder_call_prepare_summary().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
egdbus_folder_call_prepare_summary_finish (
    EGdbusFolder *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * egdbus_folder_call_prepare_summary_sync:
 * @proxy: A #EGdbusFolderProxy.
 * @arg_ops: Argument to pass with the method invocation.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.prepareSummary">prepareSummary()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See egdbus_folder_call_prepare_summary() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
egdbus_folder_call_prepare_summary_sync (
    EGdbusFolder *proxy,
    const gchar *arg_ops,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "prepareSummary",
    g_variant_new ("(o)",
                   arg_ops),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * egdbus_folder_call_freeze_folder:
 * @proxy: A #EGdbusFolderProxy.
 * @arg_ops: Argument to pass with the method invocation.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.freezeFolder">freezeFolder()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call egdbus_folder_call_freeze_folder_finish() to get the result of the operation.
 *
 * See egdbus_folder_call_freeze_folder_sync() for the synchronous, blocking version of this method.
 */
void
egdbus_folder_call_freeze_folder (
    EGdbusFolder *proxy,
    const gchar *arg_ops,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "freezeFolder",
    g_variant_new ("(o)",
                   arg_ops),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * egdbus_folder_call_freeze_folder_finish:
 * @proxy: A #EGdbusFolderProxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to egdbus_folder_call_freeze_folder().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with egdbus_folder_call_freeze_folder().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
egdbus_folder_call_freeze_folder_finish (
    EGdbusFolder *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * egdbus_folder_call_freeze_folder_sync:
 * @proxy: A #EGdbusFolderProxy.
 * @arg_ops: Argument to pass with the method invocation.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.freezeFolder">freezeFolder()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See egdbus_folder_call_freeze_folder() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
egdbus_folder_call_freeze_folder_sync (
    EGdbusFolder *proxy,
    const gchar *arg_ops,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "freezeFolder",
    g_variant_new ("(o)",
                   arg_ops),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * egdbus_folder_call_thaw_folder:
 * @proxy: A #EGdbusFolderProxy.
 * @arg_ops: Argument to pass with the method invocation.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.thawFolder">thawFolder()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call egdbus_folder_call_thaw_folder_finish() to get the result of the operation.
 *
 * See egdbus_folder_call_thaw_folder_sync() for the synchronous, blocking version of this method.
 */
void
egdbus_folder_call_thaw_folder (
    EGdbusFolder *proxy,
    const gchar *arg_ops,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "thawFolder",
    g_variant_new ("(o)",
                   arg_ops),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * egdbus_folder_call_thaw_folder_finish:
 * @proxy: A #EGdbusFolderProxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to egdbus_folder_call_thaw_folder().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with egdbus_folder_call_thaw_folder().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
egdbus_folder_call_thaw_folder_finish (
    EGdbusFolder *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * egdbus_folder_call_thaw_folder_sync:
 * @proxy: A #EGdbusFolderProxy.
 * @arg_ops: Argument to pass with the method invocation.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.thawFolder">thawFolder()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See egdbus_folder_call_thaw_folder() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
egdbus_folder_call_thaw_folder_sync (
    EGdbusFolder *proxy,
    const gchar *arg_ops,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "thawFolder",
    g_variant_new ("(o)",
                   arg_ops),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * egdbus_folder_complete_refresh_info:
 * @object: A #EGdbusFolder.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 * @success: Parameter to return.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.refreshInfo">refreshInfo()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
egdbus_folder_complete_refresh_info (
    EGdbusFolder *object,
    GDBusMethodInvocation *invocation,
    gboolean success)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("(b)",
                   success));
}

/**
 * egdbus_folder_complete_sync:
 * @object: A #EGdbusFolder.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 * @success: Parameter to return.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.sync">sync()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
egdbus_folder_complete_sync (
    EGdbusFolder *object,
    GDBusMethodInvocation *invocation,
    gboolean success)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("(b)",
                   success));
}

/**
 * egdbus_folder_complete_sync_message:
 * @object: A #EGdbusFolder.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 * @success: Parameter to return.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.syncMessage">syncMessage()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
egdbus_folder_complete_sync_message (
    EGdbusFolder *object,
    GDBusMethodInvocation *invocation,
    gboolean success)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("(b)",
                   success));
}

/**
 * egdbus_folder_complete_expunge:
 * @object: A #EGdbusFolder.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 * @success: Parameter to return.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.expunge">expunge()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
egdbus_folder_complete_expunge (
    EGdbusFolder *object,
    GDBusMethodInvocation *invocation,
    gboolean success)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("(b)",
                   success));
}

/**
 * egdbus_folder_complete_get_display_name:
 * @object: A #EGdbusFolder.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 * @name: Parameter to return.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.getDisplayName">getDisplayName()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
egdbus_folder_complete_get_display_name (
    EGdbusFolder *object,
    GDBusMethodInvocation *invocation,
    const gchar *name)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("(s)",
                   name));
}

/**
 * egdbus_folder_complete_set_display_name:
 * @object: A #EGdbusFolder.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.setDisplayName">setDisplayName()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
egdbus_folder_complete_set_display_name (
    EGdbusFolder *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/**
 * egdbus_folder_complete_get_full_name:
 * @object: A #EGdbusFolder.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 * @name: Parameter to return.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.getFullName">getFullName()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
egdbus_folder_complete_get_full_name (
    EGdbusFolder *object,
    GDBusMethodInvocation *invocation,
    const gchar *name)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("(s)",
                   name));
}

/**
 * egdbus_folder_complete_set_full_name:
 * @object: A #EGdbusFolder.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.setFullName">setFullName()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
egdbus_folder_complete_set_full_name (
    EGdbusFolder *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/**
 * egdbus_folder_complete_get_description:
 * @object: A #EGdbusFolder.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 * @desc: Parameter to return.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.getDescription">getDescription()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
egdbus_folder_complete_get_description (
    EGdbusFolder *object,
    GDBusMethodInvocation *invocation,
    const gchar *desc)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("(s)",
                   desc));
}

/**
 * egdbus_folder_complete_set_description:
 * @object: A #EGdbusFolder.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.setDescription">setDescription()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
egdbus_folder_complete_set_description (
    EGdbusFolder *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/**
 * egdbus_folder_complete_get_permanent_flags:
 * @object: A #EGdbusFolder.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 * @flags: Parameter to return.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.getPermanentFlags">getPermanentFlags()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
egdbus_folder_complete_get_permanent_flags (
    EGdbusFolder *object,
    GDBusMethodInvocation *invocation,
    guint flags)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("(u)",
                   flags));
}

/**
 * egdbus_folder_complete_has_summary_capability:
 * @object: A #EGdbusFolder.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 * @summary: Parameter to return.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.hasSummaryCapability">hasSummaryCapability()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
egdbus_folder_complete_has_summary_capability (
    EGdbusFolder *object,
    GDBusMethodInvocation *invocation,
    gboolean summary)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("(b)",
                   summary));
}

/**
 * egdbus_folder_complete_has_search_capability:
 * @object: A #EGdbusFolder.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 * @search: Parameter to return.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.hasSearchCapability">hasSearchCapability()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
egdbus_folder_complete_has_search_capability (
    EGdbusFolder *object,
    GDBusMethodInvocation *invocation,
    gboolean search)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("(b)",
                   search));
}

/**
 * egdbus_folder_complete_total_message_count:
 * @object: A #EGdbusFolder.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 * @count: Parameter to return.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.totalMessageCount">totalMessageCount()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
egdbus_folder_complete_total_message_count (
    EGdbusFolder *object,
    GDBusMethodInvocation *invocation,
    gint count)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("(i)",
                   count));
}

/**
 * egdbus_folder_complete_unread_message_count:
 * @object: A #EGdbusFolder.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 * @count: Parameter to return.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.unreadMessageCount">unreadMessageCount()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
egdbus_folder_complete_unread_message_count (
    EGdbusFolder *object,
    GDBusMethodInvocation *invocation,
    gint count)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("(i)",
                   count));
}

/**
 * egdbus_folder_complete_deleted_message_count:
 * @object: A #EGdbusFolder.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 * @count: Parameter to return.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.deletedMessageCount">deletedMessageCount()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
egdbus_folder_complete_deleted_message_count (
    EGdbusFolder *object,
    GDBusMethodInvocation *invocation,
    gint count)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("(i)",
                   count));
}

/**
 * egdbus_folder_complete_get_message_flags:
 * @object: A #EGdbusFolder.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 * @flags: Parameter to return.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.getMessageFlags">getMessageFlags()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
egdbus_folder_complete_get_message_flags (
    EGdbusFolder *object,
    GDBusMethodInvocation *invocation,
    guint flags)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("(u)",
                   flags));
}

/**
 * egdbus_folder_complete_set_message_flags:
 * @object: A #EGdbusFolder.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 * @success: Parameter to return.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.setMessageFlags">setMessageFlags()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
egdbus_folder_complete_set_message_flags (
    EGdbusFolder *object,
    GDBusMethodInvocation *invocation,
    gboolean success)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("(b)",
                   success));
}

/**
 * egdbus_folder_complete_get_message_user_flag:
 * @object: A #EGdbusFolder.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 * @flag: Parameter to return.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.getMessageUserFlag">getMessageUserFlag()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
egdbus_folder_complete_get_message_user_flag (
    EGdbusFolder *object,
    GDBusMethodInvocation *invocation,
    gboolean flag)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("(b)",
                   flag));
}

/**
 * egdbus_folder_complete_set_message_user_flag:
 * @object: A #EGdbusFolder.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.setMessageUserFlag">setMessageUserFlag()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
egdbus_folder_complete_set_message_user_flag (
    EGdbusFolder *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/**
 * egdbus_folder_complete_get_message_user_tag:
 * @object: A #EGdbusFolder.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 * @value: Parameter to return.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.getMessageUserTag">getMessageUserTag()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
egdbus_folder_complete_get_message_user_tag (
    EGdbusFolder *object,
    GDBusMethodInvocation *invocation,
    const gchar *value)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("(s)",
                   value));
}

/**
 * egdbus_folder_complete_set_message_user_tag:
 * @object: A #EGdbusFolder.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.setMessageUserTag">setMessageUserTag()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
egdbus_folder_complete_set_message_user_tag (
    EGdbusFolder *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/**
 * egdbus_folder_complete_get_parent_store:
 * @object: A #EGdbusFolder.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 * @store: Parameter to return.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.getParentStore">getParentStore()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
egdbus_folder_complete_get_parent_store (
    EGdbusFolder *object,
    GDBusMethodInvocation *invocation,
    const gchar *store)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("(o)",
                   store));
}

/**
 * egdbus_folder_complete_append_message:
 * @object: A #EGdbusFolder.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 * @appendeduid: Parameter to return.
 * @success: Parameter to return.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.AppendMessage">AppendMessage()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
egdbus_folder_complete_append_message (
    EGdbusFolder *object,
    GDBusMethodInvocation *invocation,
    const gchar *appendeduid,
    gboolean success)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("(sb)",
                   appendeduid,
                   success));
}

/**
 * egdbus_folder_complete_get_uids:
 * @object: A #EGdbusFolder.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 * @uids: Parameter to return.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.getUids">getUids()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
egdbus_folder_complete_get_uids (
    EGdbusFolder *object,
    GDBusMethodInvocation *invocation,
    const gchar *const *uids)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("(^as)",
                   uids));
}

/**
 * egdbus_folder_complete_get_message:
 * @object: A #EGdbusFolder.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 * @message: Parameter to return.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.getMessage">getMessage()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
egdbus_folder_complete_get_message (
    EGdbusFolder *object,
    GDBusMethodInvocation *invocation,
    const gchar *message)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("(s)",
                   message));
}

/**
 * egdbus_folder_complete_get_quota_info:
 * @object: A #EGdbusFolder.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 * @quotainfo: Parameter to return.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.getQuotaInfo">getQuotaInfo()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
egdbus_folder_complete_get_quota_info (
    EGdbusFolder *object,
    GDBusMethodInvocation *invocation,
    GVariant *quotainfo)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("(@a(stt))",
                   quotainfo));
}

/**
 * egdbus_folder_complete_search_by_expression:
 * @object: A #EGdbusFolder.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 * @uids: Parameter to return.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.searchByExpression">searchByExpression()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
egdbus_folder_complete_search_by_expression (
    EGdbusFolder *object,
    GDBusMethodInvocation *invocation,
    const gchar *const *uids)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("(^as)",
                   uids));
}

/**
 * egdbus_folder_complete_search_sort_by_expression:
 * @object: A #EGdbusFolder.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 * @uids: Parameter to return.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.searchSortByExpression">searchSortByExpression()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
egdbus_folder_complete_search_sort_by_expression (
    EGdbusFolder *object,
    GDBusMethodInvocation *invocation,
    const gchar *const *uids)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("(^as)",
                   uids));
}

/**
 * egdbus_folder_complete_search_by_uids:
 * @object: A #EGdbusFolder.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 * @resultuids: Parameter to return.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.searchByUids">searchByUids()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
egdbus_folder_complete_search_by_uids (
    EGdbusFolder *object,
    GDBusMethodInvocation *invocation,
    const gchar *const *resultuids)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("(^as)",
                   resultuids));
}

/**
 * egdbus_folder_complete_get_message_info:
 * @object: A #EGdbusFolder.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 * @info: Parameter to return.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.getMessageInfo">getMessageInfo()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
egdbus_folder_complete_get_message_info (
    EGdbusFolder *object,
    GDBusMethodInvocation *invocation,
    GVariant *info)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("(@(sssssssuutttiatasa(ss)))",
                   info));
}

/**
 * egdbus_folder_complete_transfer_messages_to:
 * @object: A #EGdbusFolder.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 * @returnuids: Parameter to return.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.transferMessagesTo">transferMessagesTo()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
egdbus_folder_complete_transfer_messages_to (
    EGdbusFolder *object,
    GDBusMethodInvocation *invocation,
    const gchar *const *returnuids)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("(^as)",
                   returnuids));
}

/**
 * egdbus_folder_complete_prepare_summary:
 * @object: A #EGdbusFolder.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.prepareSummary">prepareSummary()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
egdbus_folder_complete_prepare_summary (
    EGdbusFolder *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/**
 * egdbus_folder_complete_freeze_folder:
 * @object: A #EGdbusFolder.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.freezeFolder">freezeFolder()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
egdbus_folder_complete_freeze_folder (
    EGdbusFolder *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/**
 * egdbus_folder_complete_thaw_folder:
 * @object: A #EGdbusFolder.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-gnome-evolution-dataserver-mail-Folder.thawFolder">thawFolder()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
egdbus_folder_complete_thaw_folder (
    EGdbusFolder *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/* ------------------------------------------------------------------------ */

/**
 * EGdbusFolderProxy:
 *
 * The #EGdbusFolderProxy structure contains only private data and should only be accessed using the provided API.
 */

/**
 * EGdbusFolderProxyClass:
 * @parent_class: The parent class.
 *
 * Class structure for #EGdbusFolderProxy.
 */

struct _EGdbusFolderProxyPrivate
{
  GData *qdata;
};

static void egdbus_folder_proxy_iface_init (EGdbusFolderIface *iface);

G_DEFINE_TYPE_WITH_CODE (EGdbusFolderProxy, egdbus_folder_proxy, G_TYPE_DBUS_PROXY,
                         G_IMPLEMENT_INTERFACE (EGDBUS_TYPE_FOLDER, egdbus_folder_proxy_iface_init));

static void
egdbus_folder_proxy_finalize (GObject *object)
{
  EGdbusFolderProxy *proxy = EGDBUS_FOLDER_PROXY (object);
  g_datalist_clear (&proxy->priv->qdata);
  G_OBJECT_CLASS (egdbus_folder_proxy_parent_class)->finalize (object);
}

static void
egdbus_folder_proxy_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec)
{
}

static void
egdbus_folder_proxy_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec)
{
}

static void
egdbus_folder_proxy_g_signal (GDBusProxy *proxy,
  const gchar *sender_name,
  const gchar *signal_name,
  GVariant *parameters)
{
  _ExtendedGDBusSignalInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint n;
  guint signal_id;
  info = (_ExtendedGDBusSignalInfo *) g_dbus_interface_info_lookup_signal ((GDBusInterfaceInfo *) &_egdbus_folder_interface_info, signal_name);
  if (info == NULL)
    return;
  num_params = g_variant_n_children (parameters);
  paramv = g_new0 (GValue, num_params + 1);
  g_value_init (&paramv[0], EGDBUS_TYPE_FOLDER);
  g_value_set_object (&paramv[0], proxy);
  g_variant_iter_init (&iter, parameters);
  n = 1;
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.args[n - 1];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, EGDBUS_TYPE_FOLDER);
  g_signal_emitv (paramv, signal_id, 0, NULL);
  for (n = 0; n < num_params + 1; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static void
egdbus_folder_proxy_g_properties_changed (GDBusProxy *_proxy,
  GVariant *changed_properties,
  const gchar *const *invalidated_properties)
{
  EGdbusFolderProxy *proxy = EGDBUS_FOLDER_PROXY (_proxy);
  guint n;
  const gchar *key;
  GVariantIter *iter;
  _ExtendedGDBusPropertyInfo *info;
  g_variant_get (changed_properties, "a{sv}", &iter);
  while (g_variant_iter_next (iter, "{&sv}", &key, NULL))
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_egdbus_folder_interface_info, key);
      g_datalist_remove_data (&proxy->priv->qdata, key);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
  g_variant_iter_free (iter);
  for (n = 0; invalidated_properties[n] != NULL; n++)
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_egdbus_folder_interface_info, invalidated_properties[n]);
      g_datalist_remove_data (&proxy->priv->qdata, invalidated_properties[n]);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
}

static void
egdbus_folder_proxy_init (EGdbusFolderProxy *proxy)
{
  proxy->priv = G_TYPE_INSTANCE_GET_PRIVATE (proxy, EGDBUS_TYPE_FOLDER_PROXY, EGdbusFolderProxyPrivate);
  g_dbus_proxy_set_interface_info (G_DBUS_PROXY (proxy), egdbus_folder_interface_info ());
}

static void
egdbus_folder_proxy_class_init (EGdbusFolderProxyClass *klass)
{
  GObjectClass *gobject_class;
  GDBusProxyClass *proxy_class;

  g_type_class_add_private (klass, sizeof (EGdbusFolderProxyPrivate));

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize     = egdbus_folder_proxy_finalize;
  gobject_class->get_property = egdbus_folder_proxy_get_property;
  gobject_class->set_property = egdbus_folder_proxy_set_property;

  proxy_class = G_DBUS_PROXY_CLASS (klass);
  proxy_class->g_signal = egdbus_folder_proxy_g_signal;
  proxy_class->g_properties_changed = egdbus_folder_proxy_g_properties_changed;

}

static void
egdbus_folder_proxy_iface_init (EGdbusFolderIface *iface)
{
}

/**
 * egdbus_folder_proxy_new:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-gnome-evolution-dataserver-mail-Folder.top_of_page">org.gnome.evolution.dataserver.mail.Folder</link>. See g_dbus_proxy_new() for more details.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call egdbus_folder_proxy_new_finish() to get the result of the operation.
 *
 * See egdbus_folder_proxy_new_sync() for the synchronous, blocking version of this constructor.
 */
void
egdbus_folder_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (EGDBUS_TYPE_FOLDER_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.gnome.evolution.dataserver.mail.Folder", NULL);
}

/**
 * egdbus_folder_proxy_new_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to egdbus_folder_proxy_new().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with egdbus_folder_proxy_new().
 *
 * Returns: (transfer full) (type EGdbusFolderProxy): The constructed proxy object or %NULL if @error is set.
 */
EGdbusFolder *
egdbus_folder_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return EGDBUS_FOLDER (ret);
  else
    return NULL;
}

/**
 * egdbus_folder_proxy_new_sync:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Synchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-gnome-evolution-dataserver-mail-Folder.top_of_page">org.gnome.evolution.dataserver.mail.Folder</link>. See g_dbus_proxy_new_sync() for more details.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See egdbus_folder_proxy_new() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type EGdbusFolderProxy): The constructed proxy object or %NULL if @error is set.
 */
EGdbusFolder *
egdbus_folder_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (EGDBUS_TYPE_FOLDER_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.gnome.evolution.dataserver.mail.Folder", NULL);
  if (ret != NULL)
    return EGDBUS_FOLDER (ret);
  else
    return NULL;
}


/**
 * egdbus_folder_proxy_new_for_bus:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Like egdbus_folder_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call egdbus_folder_proxy_new_for_bus_finish() to get the result of the operation.
 *
 * See egdbus_folder_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
 */
void
egdbus_folder_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (EGDBUS_TYPE_FOLDER_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.gnome.evolution.dataserver.mail.Folder", NULL);
}

/**
 * egdbus_folder_proxy_new_for_bus_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to egdbus_folder_proxy_new_for_bus().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with egdbus_folder_proxy_new_for_bus().
 *
 * Returns: (transfer full) (type EGdbusFolderProxy): The constructed proxy object or %NULL if @error is set.
 */
EGdbusFolder *
egdbus_folder_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return EGDBUS_FOLDER (ret);
  else
    return NULL;
}

/**
 * egdbus_folder_proxy_new_for_bus_sync:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Like egdbus_folder_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See egdbus_folder_proxy_new_for_bus() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type EGdbusFolderProxy): The constructed proxy object or %NULL if @error is set.
 */
EGdbusFolder *
egdbus_folder_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (EGDBUS_TYPE_FOLDER_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.gnome.evolution.dataserver.mail.Folder", NULL);
  if (ret != NULL)
    return EGDBUS_FOLDER (ret);
  else
    return NULL;
}


/* ------------------------------------------------------------------------ */

/**
 * EGdbusFolderSkeleton:
 *
 * The #EGdbusFolderSkeleton structure contains only private data and should only be accessed using the provided API.
 */

/**
 * EGdbusFolderSkeletonClass:
 * @parent_class: The parent class.
 *
 * Class structure for #EGdbusFolderSkeleton.
 */

struct _EGdbusFolderSkeletonPrivate
{
  GValueArray *properties;
  GList *changed_properties;
  GSource *changed_properties_idle_source;
  GMainContext *context;
  GMutex *lock;
};

static void
_egdbus_folder_skeleton_handle_method_call (
  GDBusConnection *connection,
  const gchar *sender,
  const gchar *object_path,
  const gchar *interface_name,
  const gchar *method_name,
  GVariant *parameters,
  GDBusMethodInvocation *invocation,
  gpointer user_data)
{
  EGdbusFolderSkeleton *skeleton = EGDBUS_FOLDER_SKELETON (user_data);
  _ExtendedGDBusMethodInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint num_extra;
  guint n;
  guint signal_id;
  GValue return_value = {0};
  info = (_ExtendedGDBusMethodInfo *) g_dbus_method_invocation_get_method_info (invocation);
  g_assert (info != NULL);
  num_params = g_variant_n_children (parameters);
  num_extra = info->pass_fdlist ? 3 : 2;  paramv = g_new0 (GValue, num_params + num_extra);
  n = 0;
  g_value_init (&paramv[n], EGDBUS_TYPE_FOLDER);
  g_value_set_object (&paramv[n++], skeleton);
  g_value_init (&paramv[n], G_TYPE_DBUS_METHOD_INVOCATION);
  g_value_set_object (&paramv[n++], invocation);
  if (info->pass_fdlist)
    {
#ifdef G_OS_UNIX
      g_value_init (&paramv[n], G_TYPE_UNIX_FD_LIST);
      g_value_set_object (&paramv[n++], g_dbus_message_get_unix_fd_list (g_dbus_method_invocation_get_message (invocation)));
#else
      g_assert_not_reached ();
#endif
    }
  g_variant_iter_init (&iter, parameters);
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.in_args[n - num_extra];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, EGDBUS_TYPE_FOLDER);
  g_value_init (&return_value, G_TYPE_BOOLEAN);
  g_signal_emitv (paramv, signal_id, 0, &return_value);
  if (!g_value_get_boolean (&return_value))
    g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_UNKNOWN_METHOD, "Method %s is not implemented on interface %s", method_name, interface_name);
  g_value_unset (&return_value);
  for (n = 0; n < num_params + num_extra; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static GVariant *
_egdbus_folder_skeleton_handle_get_property (
  GDBusConnection *connection,
  const gchar *sender,
  const gchar *object_path,
  const gchar *interface_name,
  const gchar *property_name,
  GError **error,
  gpointer user_data)
{
  EGdbusFolderSkeleton *skeleton = EGDBUS_FOLDER_SKELETON (user_data);
  GValue value = {0};
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  GVariant *ret;
  ret = NULL;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_egdbus_folder_interface_info, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      g_value_init (&value, pspec->value_type);
      g_object_get_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      ret = g_dbus_gvalue_to_gvariant (&value, G_VARIANT_TYPE (info->parent_struct.signature));
      g_value_unset (&value);
    }
  return ret;
}

static gboolean
_egdbus_folder_skeleton_handle_set_property (
  GDBusConnection *connection,
  const gchar *sender,
  const gchar *object_path,
  const gchar *interface_name,
  const gchar *property_name,
  GVariant *variant,
  GError **error,
  gpointer user_data)
{
  EGdbusFolderSkeleton *skeleton = EGDBUS_FOLDER_SKELETON (user_data);
  GValue value = {0};
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  gboolean ret;
  ret = FALSE;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_egdbus_folder_interface_info, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      if (info->use_gvariant)
        g_value_set_variant (&value, variant);
      else
        g_dbus_gvariant_to_gvalue (variant, &value);
      g_object_set_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      g_value_unset (&value);
      ret = TRUE;
    }
  return ret;
}

static const GDBusInterfaceVTable _egdbus_folder_skeleton_vtable =
{
  _egdbus_folder_skeleton_handle_method_call,
  _egdbus_folder_skeleton_handle_get_property,
  _egdbus_folder_skeleton_handle_set_property
};

static GDBusInterfaceInfo *
egdbus_folder_skeleton_dbus_interface_get_info (GDBusInterfaceSkeleton *skeleton)
{
  return egdbus_folder_interface_info ();
}

static GDBusInterfaceVTable *
egdbus_folder_skeleton_dbus_interface_get_vtable (GDBusInterfaceSkeleton *skeleton)
{
  return (GDBusInterfaceVTable *) &_egdbus_folder_skeleton_vtable;
}

static GVariant *
egdbus_folder_skeleton_dbus_interface_get_properties (GDBusInterfaceSkeleton *_skeleton)
{
  EGdbusFolderSkeleton *skeleton = EGDBUS_FOLDER_SKELETON (_skeleton);

  GVariantBuilder builder;
  guint n;
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  if (_egdbus_folder_interface_info.parent_struct.properties == NULL)
    goto out;
  for (n = 0; _egdbus_folder_interface_info.parent_struct.properties[n] != NULL; n++)
    {
      GDBusPropertyInfo *info = _egdbus_folder_interface_info.parent_struct.properties[n];
      if (info->flags & G_DBUS_PROPERTY_INFO_FLAGS_READABLE)
        {
          GVariant *value;
          value = _egdbus_folder_skeleton_handle_get_property (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)), NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "org.gnome.evolution.dataserver.mail.Folder", info->name, NULL, skeleton);
          if (value != NULL)
            {
              g_variant_take_ref (value);
              g_variant_builder_add (&builder, "{sv}", info->name, value);
              g_variant_unref (value);
            }
        }
    }
out:
  return g_variant_builder_end (&builder);
}

static void
egdbus_folder_skeleton_dbus_interface_flush (GDBusInterfaceSkeleton *_skeleton)
{
}

static void
_egdbus_folder_on_signal_folder_changed (
    EGdbusFolder *object,
    const gchar *const *arg_uids_added,
    const gchar *const *arg_uids_removed,
    const gchar *const *arg_uids_changed,
    const gchar *const *arg_uids_recent)
{
  EGdbusFolderSkeleton *skeleton = EGDBUS_FOLDER_SKELETON (object);
  GDBusConnection *connection = g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton));
  if (connection == NULL)
    return;
  g_dbus_connection_emit_signal (connection,
    NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "org.gnome.evolution.dataserver.mail.Folder", "FolderChanged",
    g_variant_new ("(^as^as^as^as)",
                   arg_uids_added,
                   arg_uids_removed,
                   arg_uids_changed,
                   arg_uids_recent), NULL);
}

static void egdbus_folder_skeleton_iface_init (EGdbusFolderIface *iface);
G_DEFINE_TYPE_WITH_CODE (EGdbusFolderSkeleton, egdbus_folder_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_IMPLEMENT_INTERFACE (EGDBUS_TYPE_FOLDER, egdbus_folder_skeleton_iface_init));

static void
egdbus_folder_skeleton_finalize (GObject *object)
{
  EGdbusFolderSkeleton *skeleton = EGDBUS_FOLDER_SKELETON (object);
  g_list_foreach (skeleton->priv->changed_properties, (GFunc) _changed_property_free, NULL);
  g_list_free (skeleton->priv->changed_properties);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    g_source_destroy (skeleton->priv->changed_properties_idle_source);
  if (skeleton->priv->context != NULL)
    g_main_context_unref (skeleton->priv->context);
  g_mutex_free (skeleton->priv->lock);
  G_OBJECT_CLASS (egdbus_folder_skeleton_parent_class)->finalize (object);
}

static void
egdbus_folder_skeleton_init (EGdbusFolderSkeleton *skeleton)
{
  skeleton->priv = G_TYPE_INSTANCE_GET_PRIVATE (skeleton, EGDBUS_TYPE_FOLDER_SKELETON, EGdbusFolderSkeletonPrivate);
  skeleton->priv->lock = g_mutex_new ();
  skeleton->priv->context = g_main_context_get_thread_default ();
  if (skeleton->priv->context != NULL)
    g_main_context_ref (skeleton->priv->context);
}

static void
egdbus_folder_skeleton_class_init (EGdbusFolderSkeletonClass *klass)
{
  GObjectClass *gobject_class;
  GDBusInterfaceSkeletonClass *skeleton_class;

  g_type_class_add_private (klass, sizeof (EGdbusFolderSkeletonPrivate));

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize = egdbus_folder_skeleton_finalize;

  skeleton_class = G_DBUS_INTERFACE_SKELETON_CLASS (klass);
  skeleton_class->get_info = egdbus_folder_skeleton_dbus_interface_get_info;
  skeleton_class->get_properties = egdbus_folder_skeleton_dbus_interface_get_properties;
  skeleton_class->flush = egdbus_folder_skeleton_dbus_interface_flush;
  skeleton_class->get_vtable = egdbus_folder_skeleton_dbus_interface_get_vtable;
}

static void
egdbus_folder_skeleton_iface_init (EGdbusFolderIface *iface)
{
  iface->folder_changed = _egdbus_folder_on_signal_folder_changed;
}

/**
 * egdbus_folder_skeleton_new:
 *
 * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-org-gnome-evolution-dataserver-mail-Folder.top_of_page">org.gnome.evolution.dataserver.mail.Folder</link>.
 *
 * Returns: (transfer full) (type EGdbusFolderSkeleton): The skeleton object.
 */
EGdbusFolder *
egdbus_folder_skeleton_new (void)
{
  return EGDBUS_FOLDER (g_object_new (EGDBUS_TYPE_FOLDER_SKELETON, NULL));
}

